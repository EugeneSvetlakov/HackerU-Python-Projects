"""
This type stub file was generated by pyright.
"""

import socket
from scapy.as_resolvers import AS_resolver_riswhois
from scapy.config import conf
from scapy.fields import ByteEnumField, ByteField, IP6Field, LongField, PacketLenField, PacketListField, ShortField, StrField, StrFixedLenField, StrLenField
from scapy.layers.inet import IP, IPTools, TracerouteResult
from scapy.packet import Packet
from scapy.supersocket import L3RawSocket, SuperSocket

"""
IPv6 (Internet Protocol v6).
"""
if notsocket.has_ipv6:
    ...
if nothasattr(socket, "IPPROTO_IPV6"):
    ...
if nothasattr(socket, "IPPROTO_IPIP"):
    ...
if conf.route6 is None:
    ...
@conf.commands.register
def neighsol(addr, src, iface, timeout=..., chainCC=...):
    """Sends and receive an ICMPv6 Neighbor Solicitation message

    This function sends an ICMPv6 Neighbor Solicitation message
    to get the MAC address of the neighbor with specified IPv6 address address.

    'src' address is used as source of the message. Message is sent on iface.
    By default, timeout waiting for an answer is 1 second.

    If no answer is gathered, None is returned. Else, the answer is
    returned (ethernet frame).
    """
    ...

@conf.commands.register
def getmacbyip6(ip6, chainCC=...): # -> str | None:
    """Returns the MAC address corresponding to an IPv6 address

    neighborCache.get() method is used on instantiated neighbor cache.
    Resolution mechanism is described in associated doc string.

    (chainCC parameter value ends up being passed to sending function
     used to perform the resolution, if needed)
    """
    ...

ipv6nh = ...
ipv6nhcls = ...
class IP6ListField(StrField):
    __slots__ = ...
    islist = ...
    def __init__(self, name, default, count_from=..., length_from=...) -> None:
        ...
    
    def i2len(self, pkt, i): # -> int:
        ...
    
    def i2count(self, pkt, i): # -> int:
        ...
    
    def getfield(self, pkt, s): # -> tuple[Unknown, list[Unknown]]:
        ...
    
    def i2m(self, pkt, x):
        ...
    
    def i2repr(self, pkt, x): # -> str:
        ...
    


class _IPv6GuessPayload:
    name = ...
    def default_payload_class(self, p):
        ...
    


class IPv6(_IPv6GuessPayload, Packet, IPTools):
    name = ...
    fields_desc = ...
    def route(self):
        """Used to select the L2 address"""
        ...
    
    def mysummary(self): # -> str:
        ...
    
    def post_build(self, p, pay):
        ...
    
    def extract_padding(self, data): # -> tuple[Unknown, Unknown]:
        """Extract the IPv6 payload"""
        ...
    
    def hashret(self): # -> bytes | Any:
        ...
    
    def answers(self, other):
        ...
    


class IPv46(IP):
    """
    This class implements a dispatcher that is used to detect the IP version
    while parsing Raw IP pcap files.
    """
    @classmethod
    def dispatch_hook(cls, _pkt=..., *_, **kargs): # -> Type[IPv6]:
        ...
    


def inet6_register_l3(l2, l3): # -> str | None:
    ...

class IPerror6(IPv6):
    name = ...
    def answers(self, other):
        ...
    
    def mysummary(self): # -> str:
        ...
    


class PseudoIPv6(Packet):
    name = ...
    fields_desc = ...


def in6_chksum(nh, u, p):
    """
    As Specified in RFC 2460 - 8.1 Upper-Layer Checksums

    Performs IPv6 Upper Layer checksum computation.

    This function operates by filling a pseudo header class instance
    (PseudoIPv6) with:
    - Next Header value
    - the address of _final_ destination (if some Routing Header with non
    segleft field is present in underlayer classes, last address is used.)
    - the address of _real_ source (basically the source address of an
    IPv6 class instance available in the underlayer or the source address
    in HAO option if some Destination Option header found in underlayer
    includes this option).
    - the length is the length of provided payload string ('p')

    :param nh: value of upper layer protocol
    :param u: upper layer instance (TCP, UDP, ICMPv6*, ). Instance must be
        provided with all under layers (IPv6 and all extension headers,
        for example)
    :param p: the payload of the upper layer provided as a string
    """
    ...

class _IPv6ExtHdr(_IPv6GuessPayload, Packet):
    name = ...
    aliastypes = ...


_hbhopts = ...
class _OTypeField(ByteEnumField):
    """
    Modified BytEnumField that displays information regarding the IPv6 option
    based on its option type value (What should be done by nodes that process
    the option if they do not understand it ...)

    It is used by Jumbo, Pad1, PadN, RouterAlert, HAO options
    """
    pol = ...
    enroutechange = ...
    def i2repr(self, pkt, x): # -> str:
        ...
    


class HBHOptUnknown(Packet):
    name = ...
    fields_desc = ...
    def alignment_delta(self, curpos): # -> Literal[0]:
        """
        As specified in section 4.2 of RFC 2460, every options has
        an alignment requirement usually expressed xn+y, meaning
        the Option Type must appear at an integer multiple of x octets
        from the start of the header, plus y octets.

        That function is provided the current position from the
        start of the header and returns required padding length.
        """
        ...
    
    @classmethod
    def dispatch_hook(cls, _pkt=..., *args, **kargs): # -> Type[Pad1] | Type[PadN] | Type[RouterAlert] | Type[Jumbo] | Type[HAO] | Type[Self@HBHOptUnknown]:
        ...
    
    def extract_padding(self, p): # -> tuple[Literal[b''], Unknown]:
        ...
    


class Pad1(Packet):
    name = ...
    fields_desc = ...
    def alignment_delta(self, curpos): # -> Literal[0]:
        ...
    
    def extract_padding(self, p): # -> tuple[Literal[b''], Unknown]:
        ...
    


class PadN(Packet):
    name = ...
    fields_desc = ...
    def alignment_delta(self, curpos): # -> Literal[0]:
        ...
    
    def extract_padding(self, p): # -> tuple[Literal[b''], Unknown]:
        ...
    


class RouterAlert(Packet):
    name = ...
    fields_desc = ...
    def alignment_delta(self, curpos):
        ...
    
    def extract_padding(self, p): # -> tuple[Literal[b''], Unknown]:
        ...
    


class Jumbo(Packet):
    name = ...
    fields_desc = ...
    def alignment_delta(self, curpos):
        ...
    
    def extract_padding(self, p): # -> tuple[Literal[b''], Unknown]:
        ...
    


class HAO(Packet):
    name = ...
    fields_desc = ...
    def alignment_delta(self, curpos):
        ...
    
    def extract_padding(self, p): # -> tuple[Literal[b''], Unknown]:
        ...
    


_hbhoptcls = ...
class _OptionsField(PacketListField):
    __slots__ = ...
    def __init__(self, name, default, cls, curpos, *args, **kargs) -> None:
        ...
    
    def i2len(self, pkt, i): # -> int:
        ...
    
    def i2m(self, pkt, x):
        ...
    
    def addfield(self, pkt, s, val):
        ...
    


class _PhantomAutoPadField(ByteField):
    def addfield(self, pkt, s, val):
        ...
    
    def getfield(self, pkt, s): # -> tuple[Unknown, Literal[1]]:
        ...
    
    def i2repr(self, pkt, x): # -> Literal['On', 'Off']:
        ...
    


class IPv6ExtHdrHopByHop(_IPv6ExtHdr):
    name = ...
    fields_desc = ...
    overload_fields = ...


class IPv6ExtHdrDestOpt(_IPv6ExtHdr):
    name = ...
    fields_desc = ...
    overload_fields = ...


class IPv6ExtHdrRouting(_IPv6ExtHdr):
    name = ...
    fields_desc = ...
    overload_fields = ...
    def post_build(self, pkt, pay): # -> bytes:
        ...
    


_segment_routing_header_tlvs = ...
class IPv6ExtHdrSegmentRoutingTLV(Packet):
    name = ...
    fields_desc = ...
    def extract_padding(self, p): # -> tuple[Literal[b''], Unknown]:
        ...
    
    registered_sr_tlv = ...
    @classmethod
    def register_variant(cls): # -> None:
        ...
    
    @classmethod
    def dispatch_hook(cls, pkt=..., *args, **kargs): # -> Type[Self@IPv6ExtHdrSegmentRoutingTLV]:
        ...
    


class IPv6ExtHdrSegmentRoutingTLVIngressNode(IPv6ExtHdrSegmentRoutingTLV):
    name = ...
    fields_desc = ...


class IPv6ExtHdrSegmentRoutingTLVEgressNode(IPv6ExtHdrSegmentRoutingTLV):
    name = ...
    fields_desc = ...


class IPv6ExtHdrSegmentRoutingTLVPad1(IPv6ExtHdrSegmentRoutingTLV):
    name = ...
    fields_desc = ...


class IPv6ExtHdrSegmentRoutingTLVPadN(IPv6ExtHdrSegmentRoutingTLV):
    name = ...
    fields_desc = ...


class IPv6ExtHdrSegmentRoutingTLVHMAC(IPv6ExtHdrSegmentRoutingTLV):
    name = ...
    fields_desc = ...


class IPv6ExtHdrSegmentRouting(_IPv6ExtHdr):
    name = ...
    fields_desc = ...
    overload_fields = ...
    def post_build(self, pkt, pay): # -> bytes:
        ...
    


class IPv6ExtHdrFragment(_IPv6ExtHdr):
    name = ...
    fields_desc = ...
    overload_fields = ...
    def guess_payload_class(self, p): # -> Type[Raw] | Any:
        ...
    


def defragment6(packets): # -> IPv6 | list[Unknown]:
    """
    Performs defragmentation of a list of IPv6 packets. Packets are reordered.
    Crap is dropped. What lacks is completed by 'X' characters.
    """
    ...

def fragment6(pkt, fragSize):
    """
    Performs fragmentation of an IPv6 packet. 'fragSize' argument is the
    expected maximum size of fragment data (MTU). The list of packets is
    returned.

    If packet does not contain an IPv6ExtHdrFragment class, it is added to
    first IPv6 layer found. If no IPv6 layer exists packet is returned in
    result list unmodified.
    """
    ...

icmp6typescls = ...
icmp6typesminhdrlen = ...
icmp6types = ...
class _ICMPv6(Packet):
    name = ...
    overload_fields = ...
    def post_build(self, p, pay):
        ...
    
    def hashret(self): # -> bytes | Any:
        ...
    
    def answers(self, other): # -> Literal[0, 1]:
        ...
    


class _ICMPv6Error(_ICMPv6):
    name = ...
    def guess_payload_class(self, p): # -> Type[IPerror6]:
        ...
    


class ICMPv6Unknown(_ICMPv6):
    name = ...
    fields_desc = ...


class ICMPv6DestUnreach(_ICMPv6Error):
    name = ...
    fields_desc = ...


class ICMPv6PacketTooBig(_ICMPv6Error):
    name = ...
    fields_desc = ...


class ICMPv6TimeExceeded(_ICMPv6Error):
    name = ...
    fields_desc = ...


class ICMPv6ParamProblem(_ICMPv6Error):
    name = ...
    fields_desc = ...


class ICMPv6EchoRequest(_ICMPv6):
    name = ...
    fields_desc = ...
    def mysummary(self): # -> str:
        ...
    
    def hashret(self): # -> bytes | Any:
        ...
    


class ICMPv6EchoReply(ICMPv6EchoRequest):
    name = ...
    type = ...
    def answers(self, other): # -> Literal[False]:
        ...
    


class _ICMPv6ML(_ICMPv6):
    fields_desc = ...


class ICMPv6MLQuery(_ICMPv6ML):
    name = ...
    type = ...
    mrd = ...
    mladdr = ...
    overload_fields = ...


class ICMPv6MLReport(_ICMPv6ML):
    name = ...
    type = ...
    overload_fields = ...
    def answers(self, query): # -> bool:
        """Check the query type"""
        ...
    


class ICMPv6MLDone(_ICMPv6ML):
    name = ...
    type = ...
    overload_fields = ...


class ICMPv6MLQuery2(_ICMPv6):
    name = ...
    fields_desc = ...
    overload_fields = ...
    def post_build(self, packet, payload):
        """Compute the 'sources_number' field when needed"""
        ...
    


class ICMPv6MLDMultAddrRec(Packet):
    name = ...
    fields_desc = ...
    def default_payload_class(self, packet): # -> Type[Self@ICMPv6MLDMultAddrRec]:
        """Multicast Address Record followed by another one"""
        ...
    


class ICMPv6MLReport2(_ICMPv6):
    name = ...
    fields_desc = ...
    overload_fields = ...
    def post_build(self, packet, payload):
        """Compute the 'records_number' field when needed"""
        ...
    
    def answers(self, query): # -> bool:
        """Check the query type"""
        ...
    


class ICMPv6MRD_Advertisement(_ICMPv6):
    name = ...
    fields_desc = ...
    overload_fields = ...
    def extract_padding(self, s): # -> tuple[Unknown, Unknown]:
        ...
    


class ICMPv6MRD_Solicitation(_ICMPv6):
    name = ...
    fields_desc = ...
    overload_fields = ...
    def extract_padding(self, s): # -> tuple[Unknown, Unknown]:
        ...
    


class ICMPv6MRD_Termination(_ICMPv6):
    name = ...
    fields_desc = ...
    overload_fields = ...
    def extract_padding(self, s): # -> tuple[Unknown, Unknown]:
        ...
    


icmp6ndopts = ...
icmp6ndoptscls = ...
icmp6ndraprefs = ...
class _ICMPv6NDGuessPayload:
    name = ...
    def guess_payload_class(self, p): # -> str | Type[Raw] | None:
        ...
    


class ICMPv6NDOptUnknown(_ICMPv6NDGuessPayload, Packet):
    name = ...
    fields_desc = ...


class ICMPv6NDOptSrcLLAddr(_ICMPv6NDGuessPayload, Packet):
    name = ...
    fields_desc = ...
    def mysummary(self): # -> str:
        ...
    


class ICMPv6NDOptDstLLAddr(ICMPv6NDOptSrcLLAddr):
    name = ...
    type = ...


class ICMPv6NDOptPrefixInfo(_ICMPv6NDGuessPayload, Packet):
    name = ...
    fields_desc = ...
    def mysummary(self): # -> str:
        ...
    


class TruncPktLenField(PacketLenField):
    __slots__ = ...
    def __init__(self, name, default, cls, cur_shift, length_from=..., shift=...) -> None:
        ...
    
    def getfield(self, pkt, s): # -> tuple[Unknown, alternative]:
        ...
    
    def m2i(self, pkt, m): # -> Any:
        ...
    
    def i2m(self, pkt, x): # -> bytes:
        ...
    
    def i2len(self, pkt, i): # -> int:
        ...
    


class ICMPv6NDOptRedirectedHdr(_ICMPv6NDGuessPayload, Packet):
    name = ...
    fields_desc = ...


class ICMPv6NDOptMTU(_ICMPv6NDGuessPayload, Packet):
    name = ...
    fields_desc = ...
    def mysummary(self): # -> str:
        ...
    


class ICMPv6NDOptShortcutLimit(_ICMPv6NDGuessPayload, Packet):
    name = ...
    fields_desc = ...


class ICMPv6NDOptAdvInterval(_ICMPv6NDGuessPayload, Packet):
    name = ...
    fields_desc = ...
    def mysummary(self): # -> str:
        ...
    


class ICMPv6NDOptHAInfo(_ICMPv6NDGuessPayload, Packet):
    name = ...
    fields_desc = ...
    def mysummary(self): # -> str:
        ...
    


class ICMPv6NDOptIPAddr(_ICMPv6NDGuessPayload, Packet):
    name = ...
    fields_desc = ...


class ICMPv6NDOptNewRtrPrefix(_ICMPv6NDGuessPayload, Packet):
    name = ...
    fields_desc = ...


_rfc4068_lla_optcode = ...
class ICMPv6NDOptLLA(_ICMPv6NDGuessPayload, Packet):
    name = ...
    fields_desc = ...


class ICMPv6NDOptMAP(_ICMPv6NDGuessPayload, Packet):
    name = ...
    fields_desc = ...


class _IP6PrefixField(IP6Field):
    __slots__ = ...
    def __init__(self, name, default) -> None:
        ...
    
    def addfield(self, pkt, s, val):
        ...
    
    def getfield(self, pkt, s): # -> tuple[Unknown, str]:
        ...
    
    def i2len(self, pkt, x): # -> int:
        ...
    
    def i2m(self, pkt, x): # -> bytes:
        ...
    


class ICMPv6NDOptRouteInfo(_ICMPv6NDGuessPayload, Packet):
    name = ...
    fields_desc = ...
    def mysummary(self): # -> str:
        ...
    


class ICMPv6NDOptRDNSS(_ICMPv6NDGuessPayload, Packet):
    name = ...
    fields_desc = ...
    def mysummary(self): # -> str:
        ...
    


class ICMPv6NDOptEFA(_ICMPv6NDGuessPayload, Packet):
    name = ...
    fields_desc = ...


class DomainNameListField(StrLenField):
    __slots__ = ...
    islist = ...
    padded_unit = ...
    def __init__(self, name, default, length_from=..., padded=...) -> None:
        ...
    
    def i2len(self, pkt, x): # -> int:
        ...
    
    def m2i(self, pkt, x):
        ...
    
    def i2m(self, pkt, x): # -> bytes:
        ...
    


class ICMPv6NDOptDNSSL(_ICMPv6NDGuessPayload, Packet):
    name = ...
    fields_desc = ...
    def mysummary(self): # -> str:
        ...
    


class ICMPv6ND_RS(_ICMPv6NDGuessPayload, _ICMPv6):
    name = ...
    fields_desc = ...
    overload_fields = ...


class ICMPv6ND_RA(_ICMPv6NDGuessPayload, _ICMPv6):
    name = ...
    fields_desc = ...
    overload_fields = ...
    def answers(self, other): # -> bool:
        ...
    
    def mysummary(self): # -> str:
        ...
    


class ICMPv6ND_NS(_ICMPv6NDGuessPayload, _ICMPv6, Packet):
    name = ...
    fields_desc = ...
    overload_fields = ...
    def mysummary(self): # -> str:
        ...
    
    def hashret(self): # -> bytes | Any:
        ...
    


class ICMPv6ND_NA(_ICMPv6NDGuessPayload, _ICMPv6, Packet):
    name = ...
    fields_desc = ...
    overload_fields = ...
    def mysummary(self): # -> str:
        ...
    
    def hashret(self): # -> bytes | Any:
        ...
    
    def answers(self, other): # -> Literal[False]:
        ...
    


class ICMPv6ND_Redirect(_ICMPv6NDGuessPayload, _ICMPv6, Packet):
    name = ...
    fields_desc = ...
    overload_fields = ...


class ICMPv6NDOptSrcAddrList(_ICMPv6NDGuessPayload, Packet):
    name = ...
    fields_desc = ...


class ICMPv6NDOptTgtAddrList(ICMPv6NDOptSrcAddrList):
    name = ...
    type = ...


class ICMPv6ND_INDSol(_ICMPv6NDGuessPayload, _ICMPv6):
    name = ...
    fields_desc = ...
    overload_fields = ...


class ICMPv6ND_INDAdv(_ICMPv6NDGuessPayload, _ICMPv6):
    name = ...
    fields_desc = ...
    overload_fields = ...


icmp6_niqtypes = ...
class _ICMPv6NIHashret:
    def hashret(self): # -> bytes:
        ...
    


class _ICMPv6NIAnswers:
    def answers(self, other):
        ...
    


class NonceField(StrFixedLenField):
    def __init__(self, name, default=...) -> None:
        ...
    


@conf.commands.register
def computeNIGroupAddr(name): # -> str:
    """Compute the NI group Address. Can take a FQDN as input parameter"""
    ...

def names2dnsrepr(x): # -> bytes:
    """
    Take as input a list of DNS names or a single DNS name
    and encode it in DNS format (with possible compression)
    If a string that is already a DNS name in DNS format
    is passed, it is returned unmodified. Result is a string.
    !!!  At the moment, compression is not implemented  !!!
    """
    ...

def dnsrepr2names(x): # -> list[Unknown]:
    """
    Take as input a DNS encoded string (possibly compressed)
    and returns a list of DNS names contained in it.
    If provided string is already in printable format
    (does not end with a null character, a one element list
    is returned). Result is a list.
    """
    ...

class NIQueryDataField(StrField):
    def __init__(self, name, default) -> None:
        ...
    
    def i2h(self, pkt, x):
        ...
    
    def h2i(self, pkt, x):
        ...
    
    def i2repr(self, pkt, x): # -> str:
        ...
    
    def getfield(self, pkt, s): # -> tuple[Unknown, tuple[Literal[0], Literal[b'']]] | tuple[Unknown, tuple[Literal[0], str]] | tuple[Unknown, tuple[Literal[2], str]] | tuple[Literal[b''], tuple[Literal[1], Unknown]]:
        ...
    
    def addfield(self, pkt, s, val):
        ...
    


class NIQueryCodeField(ByteEnumField):
    def i2m(self, pkt, x): # -> Literal[1, 0, 2]:
        ...
    


_niquery_code = ...
class ICMPv6NIQueryNOOP(_ICMPv6NIHashret, _ICMPv6):
    name = ...
    fields_desc = ...


class ICMPv6NIQueryName(ICMPv6NIQueryNOOP):
    name = ...
    qtype = ...


class ICMPv6NIQueryIPv6(ICMPv6NIQueryNOOP):
    name = ...
    qtype = ...
    flags = ...


class ICMPv6NIQueryIPv4(ICMPv6NIQueryNOOP):
    name = ...
    qtype = ...


_nireply_code = ...
_nireply_flags = ...
class NIReplyDataField(StrField):
    def i2h(self, pkt, x): # -> list[Unknown]:
        ...
    
    def h2i(self, pkt, x):
        ...
    
    def addfield(self, pkt, s, val):
        ...
    
    def getfield(self, pkt, s): # -> tuple[Unknown, tuple[Literal[0], Literal[b'']]] | tuple[Literal[b''], tuple[Literal[2], list[Any | Unknown]]] | tuple[Unknown, tuple[Literal[3], list[Unknown]]] | tuple[Unknown, tuple[Literal[4], list[Unknown]]] | tuple[Literal[b''], tuple[Literal[0], Unknown]]:
        ...
    
    def i2repr(self, pkt, x): # -> str:
        ...
    


class ICMPv6NIReplyNOOP(_ICMPv6NIAnswers, _ICMPv6NIHashret, _ICMPv6):
    name = ...
    fields_desc = ...


class ICMPv6NIReplyName(ICMPv6NIReplyNOOP):
    name = ...
    qtype = ...


class ICMPv6NIReplyIPv6(ICMPv6NIReplyNOOP):
    name = ...
    qtype = ...


class ICMPv6NIReplyIPv4(ICMPv6NIReplyNOOP):
    name = ...
    qtype = ...


class ICMPv6NIReplyRefuse(ICMPv6NIReplyNOOP):
    name = ...
    code = ...


class ICMPv6NIReplyUnknown(ICMPv6NIReplyNOOP):
    name = ...
    code = ...


rplcodes = ...
class ICMPv6RPL(_ICMPv6):
    name = ...
    fields_desc = ...
    overload_fields = ...


class ICMPv6HAADRequest(_ICMPv6):
    name = ...
    fields_desc = ...
    def hashret(self): # -> bytes | Any:
        ...
    


class ICMPv6HAADReply(_ICMPv6):
    name = ...
    fields_desc = ...
    def hashret(self): # -> bytes | Any:
        ...
    
    def answers(self, other): # -> Literal[0]:
        ...
    


class ICMPv6MPSol(_ICMPv6):
    name = ...
    fields_desc = ...


class ICMPv6MPAdv(_ICMPv6NDGuessPayload, _ICMPv6):
    name = ...
    fields_desc = ...
    def hashret(self): # -> bytes:
        ...
    
    def answers(self, other): # -> bool:
        ...
    


_mobopttypes = ...
class _MIP6OptAlign(Packet):
    """ Mobile IPv6 options have alignment requirements of the form x*n+y.
    This class is inherited by all MIPv6 options to help in computing the
    required Padding for that option, i.e. the need for a Pad1 or PadN
    option before it. They only need to provide x and y as class
    parameters. (x=0 and y=0 are used when no alignment is required)"""
    __slots__ = ...
    def alignment_delta(self, curpos): # -> Literal[0]:
        ...
    
    def extract_padding(self, p): # -> tuple[Literal[b''], Unknown]:
        ...
    


class MIP6OptBRAdvice(_MIP6OptAlign):
    name = ...
    fields_desc = ...
    x = ...
    y = ...


class MIP6OptAltCoA(_MIP6OptAlign):
    name = ...
    fields_desc = ...
    x = ...
    y = ...


class MIP6OptNonceIndices(_MIP6OptAlign):
    name = ...
    fields_desc = ...
    x = ...
    y = ...


class MIP6OptBindingAuthData(_MIP6OptAlign):
    name = ...
    fields_desc = ...
    x = ...
    y = ...


class MIP6OptMobNetPrefix(_MIP6OptAlign):
    name = ...
    fields_desc = ...
    x = ...
    y = ...


class MIP6OptLLAddr(_MIP6OptAlign):
    name = ...
    fields_desc = ...
    x = ...
    y = ...


class MIP6OptMNID(_MIP6OptAlign):
    name = ...
    fields_desc = ...
    x = ...
    y = ...


class MIP6OptMsgAuth(_MIP6OptAlign):
    name = ...
    fields_desc = ...
    x = ...
    y = ...


class NTPTimestampField(LongField):
    def i2repr(self, pkt, x): # -> str:
        ...
    


class MIP6OptReplayProtection(_MIP6OptAlign):
    name = ...
    fields_desc = ...
    x = ...
    y = ...


class MIP6OptCGAParamsReq(_MIP6OptAlign):
    name = ...
    fields_desc = ...
    x = ...
    y = ...


class MIP6OptCGAParams(_MIP6OptAlign):
    name = ...
    fields_desc = ...
    x = ...
    y = ...


class MIP6OptSignature(_MIP6OptAlign):
    name = ...
    fields_desc = ...
    x = ...
    y = ...


class MIP6OptHomeKeygenToken(_MIP6OptAlign):
    name = ...
    fields_desc = ...
    x = ...
    y = ...


class MIP6OptCareOfTestInit(_MIP6OptAlign):
    name = ...
    fields_desc = ...
    x = ...
    y = ...


class MIP6OptCareOfTest(_MIP6OptAlign):
    name = ...
    fields_desc = ...
    x = ...
    y = ...


class MIP6OptUnknown(_MIP6OptAlign):
    name = ...
    fields_desc = ...
    x = ...
    y = ...
    @classmethod
    def dispatch_hook(cls, _pkt=..., *_, **kargs): # -> Type[Pad1] | Type[PadN] | Type[MIP6OptBRAdvice] | Type[MIP6OptAltCoA] | Type[MIP6OptNonceIndices] | Type[MIP6OptBindingAuthData] | Type[MIP6OptMobNetPrefix] | Type[MIP6OptLLAddr] | Type[MIP6OptMNID] | Type[MIP6OptMsgAuth] | Type[MIP6OptReplayProtection] | Type[MIP6OptCGAParamsReq] | Type[MIP6OptCGAParams] | Type[MIP6OptSignature] | Type[MIP6OptHomeKeygenToken] | Type[MIP6OptCareOfTestInit] | Type[MIP6OptCareOfTest] | Type[Self@MIP6OptUnknown]:
        ...
    


moboptcls = ...
mhtypes = ...
bastatus = ...
class _MobilityHeader(Packet):
    name = ...
    overload_fields = ...
    def post_build(self, p, pay):
        ...
    


class MIP6MH_Generic(_MobilityHeader):
    name = ...
    fields_desc = ...


class MIP6MH_BRR(_MobilityHeader):
    name = ...
    fields_desc = ...
    overload_fields = ...
    def hashret(self): # -> Literal[b'\u0000\b\t']:
        ...
    


class MIP6MH_HoTI(_MobilityHeader):
    name = ...
    fields_desc = ...
    overload_fields = ...
    def hashret(self): # -> bytes:
        ...
    


class MIP6MH_CoTI(MIP6MH_HoTI):
    name = ...
    mhtype = ...
    def hashret(self): # -> bytes:
        ...
    


class MIP6MH_HoT(_MobilityHeader):
    name = ...
    fields_desc = ...
    overload_fields = ...
    def hashret(self): # -> bytes:
        ...
    
    def answers(self, other): # -> Literal[1, 0]:
        ...
    


class MIP6MH_CoT(MIP6MH_HoT):
    name = ...
    mhtype = ...
    def hashret(self): # -> bytes:
        ...
    
    def answers(self, other): # -> Literal[1, 0]:
        ...
    


class LifetimeField(ShortField):
    def i2repr(self, pkt, x):
        ...
    


class MIP6MH_BU(_MobilityHeader):
    name = ...
    fields_desc = ...
    overload_fields = ...
    def hashret(self): # -> Literal[b'\u0000\b\t']:
        ...
    
    def answers(self, other): # -> Literal[1, 0]:
        ...
    


class MIP6MH_BA(_MobilityHeader):
    name = ...
    fields_desc = ...
    overload_fields = ...
    def hashret(self): # -> Literal[b'\u0000\b\t']:
        ...
    
    def answers(self, other): # -> Literal[1, 0]:
        ...
    


_bestatus = ...
class MIP6MH_BE(_MobilityHeader):
    name = ...
    fields_desc = ...
    overload_fields = ...


_mip6_mhtype2cls = ...
class AS_resolver6(AS_resolver_riswhois):
    ...


class TracerouteResult6(TracerouteResult):
    __slots__ = ...
    def show(self):
        ...
    
    def get_trace(self): # -> dict[Unknown, Unknown]:
        ...
    
    def graph(self, ASres=..., **kargs): # -> None:
        ...
    


@conf.commands.register
def traceroute6(target, dport=..., minttl=..., maxttl=..., sport=..., l4=..., timeout=..., verbose=..., **kargs): # -> tuple[TracerouteResult6, Any | Unknown]:
    """Instant TCP traceroute using IPv6
    traceroute6(target, [maxttl=30], [dport=80], [sport=80]) -> None
    """
    ...

class L3RawSocket6(L3RawSocket):
    def __init__(self, type=..., filter=..., iface=..., promisc=..., nofilter=...) -> None:
        ...
    


def IPv6inIP(dst=..., src=...): # -> Type[_IPv6inIP]:
    ...

class _IPv6inIP(SuperSocket):
    dst = ...
    src = ...
    cls = ...
    def __init__(self, family=..., type=..., proto=..., **args) -> None:
        ...
    
    def set(self, dst, src=...): # -> None:
        ...
    
    def nonblock_recv(self): # -> IPv6:
        ...
    
    def recv(self, x): # -> IPv6:
        ...
    
    def send(self, x):
        ...
    


def NDP_Attack_DAD_DoS_via_NS(iface=..., mac_src_filter=..., tgt_filter=..., reply_mac=...): # -> None:
    """
    Perform the DAD DoS attack using NS described in section 4.1.3 of RFC
    3756. This is done by listening incoming NS messages sent from the
    unspecified address and sending a NS reply for the target address,
    leading the peer to believe that another node is also performing DAD
    for that address.

    By default, the fake NS sent to create the DoS uses:
     - as target address the target address found in received NS.
     - as IPv6 source address: the unspecified address (::).
     - as IPv6 destination address: the link-local solicited-node multicast
       address derived from the target address in received NS.
     - the mac address of the interface as source (or reply_mac, see below).
     - the multicast mac address derived from the solicited node multicast
       address used as IPv6 destination address.

    Following arguments can be used to change the behavior:

    iface: a specific interface (e.g. "eth0") of the system on which the
         DoS should be launched. If None is provided conf.iface is used.

    mac_src_filter: a mac address (e.g "00:13:72:8c:b5:69") to filter on.
         Only NS messages received from this source will trigger replies.
         This allows limiting the effects of the DoS to a single target by
         filtering on its mac address. The default value is None: the DoS
         is not limited to a specific mac address.

    tgt_filter: Same as previous but for a specific target IPv6 address for
         received NS. If the target address in the NS message (not the IPv6
         destination address) matches that address, then a fake reply will
         be sent, i.e. the emitter will be a target of the DoS.

    reply_mac: allow specifying a specific source mac address for the reply,
         i.e. to prevent the use of the mac address of the interface.
    """
    ...

def NDP_Attack_DAD_DoS_via_NA(iface=..., mac_src_filter=..., tgt_filter=..., reply_mac=...): # -> None:
    """
    Perform the DAD DoS attack using NS described in section 4.1.3 of RFC
    3756. This is done by listening incoming NS messages *sent from the
    unspecified address* and sending a NA reply for the target address,
    leading the peer to believe that another node is also performing DAD
    for that address.

    By default, the fake NA sent to create the DoS uses:
     - as target address the target address found in received NS.
     - as IPv6 source address: the target address found in received NS.
     - as IPv6 destination address: the link-local solicited-node multicast
       address derived from the target address in received NS.
     - the mac address of the interface as source (or reply_mac, see below).
     - the multicast mac address derived from the solicited node multicast
       address used as IPv6 destination address.
     - A Target Link-Layer address option (ICMPv6NDOptDstLLAddr) filled
       with the mac address used as source of the NA.

    Following arguments can be used to change the behavior:

    iface: a specific interface (e.g. "eth0") of the system on which the
          DoS should be launched. If None is provided conf.iface is used.

    mac_src_filter: a mac address (e.g "00:13:72:8c:b5:69") to filter on.
         Only NS messages received from this source will trigger replies.
         This allows limiting the effects of the DoS to a single target by
         filtering on its mac address. The default value is None: the DoS
         is not limited to a specific mac address.

    tgt_filter: Same as previous but for a specific target IPv6 address for
         received NS. If the target address in the NS message (not the IPv6
         destination address) matches that address, then a fake reply will
         be sent, i.e. the emitter will be a target of the DoS.

    reply_mac: allow specifying a specific source mac address for the reply,
         i.e. to prevent the use of the mac address of the interface. This
         address will also be used in the Target Link-Layer Address option.
    """
    ...

def NDP_Attack_NA_Spoofing(iface=..., mac_src_filter=..., tgt_filter=..., reply_mac=..., router=...): # -> None:
    """
    The main purpose of this function is to send fake Neighbor Advertisement
    messages to a victim. As the emission of unsolicited Neighbor Advertisement
    is pretty pointless (from an attacker standpoint) because it will not
    lead to a modification of a victim's neighbor cache, the function send
    advertisements in response to received NS (NS sent as part of the DAD,
    i.e. with an unspecified address as source, are not considered).

    By default, the fake NA sent to create the DoS uses:
     - as target address the target address found in received NS.
     - as IPv6 source address: the target address
     - as IPv6 destination address: the source IPv6 address of received NS
       message.
     - the mac address of the interface as source (or reply_mac, see below).
     - the source mac address of the received NS as destination macs address
       of the emitted NA.
     - A Target Link-Layer address option (ICMPv6NDOptDstLLAddr)
       filled with the mac address used as source of the NA.

    Following arguments can be used to change the behavior:

    iface: a specific interface (e.g. "eth0") of the system on which the
          DoS should be launched. If None is provided conf.iface is used.

    mac_src_filter: a mac address (e.g "00:13:72:8c:b5:69") to filter on.
         Only NS messages received from this source will trigger replies.
         This allows limiting the effects of the DoS to a single target by
         filtering on its mac address. The default value is None: the DoS
         is not limited to a specific mac address.

    tgt_filter: Same as previous but for a specific target IPv6 address for
         received NS. If the target address in the NS message (not the IPv6
         destination address) matches that address, then a fake reply will
         be sent, i.e. the emitter will be a target of the DoS.

    reply_mac: allow specifying a specific source mac address for the reply,
         i.e. to prevent the use of the mac address of the interface. This
         address will also be used in the Target Link-Layer Address option.

    router: by the default (False) the 'R' flag in the NA used for the reply
         is not set. If the parameter is set to True, the 'R' flag in the
         NA is set, advertising us as a router.

    Please, keep the following in mind when using the function: for obvious
    reasons (kernel space vs. Python speed), when the target of the address
    resolution is on the link, the sender of the NS receives 2 NA messages
    in a row, the valid one and our fake one. The second one will overwrite
    the information provided by the first one, i.e. the natural latency of
    Scapy helps here.

    In practice, on a common Ethernet link, the emission of the NA from the
    genuine target (kernel stack) usually occurs in the same millisecond as
    the receipt of the NS. The NA generated by Scapy6 will usually come after
    something 20+ ms. On a usual testbed for instance, this difference is
    sufficient to have the first data packet sent from the victim to the
    destination before it even receives our fake NA.
    """
    ...

def NDP_Attack_NS_Spoofing(src_lladdr=..., src=..., target=..., dst=..., src_mac=..., dst_mac=..., loop=..., inter=..., iface=...): # -> None:
    """
    The main purpose of this function is to send fake Neighbor Solicitations
    messages to a victim, in order to either create a new entry in its neighbor
    cache or update an existing one. In section 7.2.3 of RFC 4861, it is stated
    that a node SHOULD create the entry or update an existing one (if it is not
    currently performing DAD for the target of the NS). The entry's reachability  # noqa: E501
    state is set to STALE.

    The two main parameters of the function are the source link-layer address
    (carried by the Source Link-Layer Address option in the NS) and the
    source address of the packet.

    Unlike some other NDP_Attack_* function, this one is not based on a
    stimulus/response model. When called, it sends the same NS packet in loop
    every second (the default)

    Following arguments can be used to change the format of the packets:

    src_lladdr: the MAC address used in the Source Link-Layer Address option
         included in the NS packet. This is the address that the peer should
         associate in its neighbor cache with the IPv6 source address of the
         packet. If None is provided, the mac address of the interface is
         used.

    src: the IPv6 address used as source of the packet. If None is provided,
         an address associated with the emitting interface will be used
         (based on the destination address of the packet).

    target: the target address of the NS packet. If no value is provided,
         a dummy address (2001:db8::1) is used. The value of the target
         has a direct impact on the destination address of the packet if it
         is not overridden. By default, the solicited-node multicast address
         associated with the target is used as destination address of the
         packet. Consider specifying a specific destination address if you
         intend to use a target address different than the one of the victim.

    dst: The destination address of the NS. By default, the solicited node
         multicast address associated with the target address (see previous
         parameter) is used if no specific value is provided. The victim
         is not expected to check the destination address of the packet,
         so using a multicast address like ff02::1 should work if you want
         the attack to target all hosts on the link. On the contrary, if
         you want to be more stealth, you should provide the target address
         for this parameter in order for the packet to be sent only to the
         victim.

    src_mac: the MAC address used as source of the packet. By default, this
         is the address of the interface. If you want to be more stealth,
         feel free to use something else. Note that this address is not the
         that the victim will use to populate its neighbor cache.

    dst_mac: The MAC address used as destination address of the packet. If
         the IPv6 destination address is multicast (all-nodes, solicited
         node, ...), it will be computed. If the destination address is
         unicast, a neighbor solicitation will be performed to get the
         associated address. If you want the attack to be stealth, you
         can provide the MAC address using this parameter.

    loop: By default, this parameter is True, indicating that NS packets
         will be sent in loop, separated by 'inter' seconds (see below).
         When set to False, a single packet is sent.

    inter: When loop parameter is True (the default), this parameter provides
         the interval in seconds used for sending NS packets.

    iface: to force the sending interface.
    """
    ...

def NDP_Attack_Kill_Default_Router(iface=..., mac_src_filter=..., ip_src_filter=..., reply_mac=..., tgt_mac=...): # -> None:
    """
    The purpose of the function is to monitor incoming RA messages
    sent by default routers (RA with a non-zero Router Lifetime values)
    and invalidate them by immediately replying with fake RA messages
    advertising a zero Router Lifetime value.

    The result on receivers is that the router is immediately invalidated,
    i.e. the associated entry is discarded from the default router list
    and destination cache is updated to reflect the change.

    By default, the function considers all RA messages with a non-zero
    Router Lifetime value but provides configuration knobs to allow
    filtering RA sent by specific routers (Ethernet source address).
    With regard to emission, the multicast all-nodes address is used
    by default but a specific target can be used, in order for the DoS to
    apply only to a specific host.

    More precisely, following arguments can be used to change the behavior:

    iface: a specific interface (e.g. "eth0") of the system on which the
         DoS should be launched. If None is provided conf.iface is used.

    mac_src_filter: a mac address (e.g "00:13:72:8c:b5:69") to filter on.
         Only RA messages received from this source will trigger replies.
         If other default routers advertised their presence on the link,
         their clients will not be impacted by the attack. The default
         value is None: the DoS is not limited to a specific mac address.

    ip_src_filter: an IPv6 address (e.g. fe80::21e:bff:fe4e:3b2) to filter
         on. Only RA messages received from this source address will trigger
         replies. If other default routers advertised their presence on the
         link, their clients will not be impacted by the attack. The default
         value is None: the DoS is not limited to a specific IPv6 source
         address.

    reply_mac: allow specifying a specific source mac address for the reply,
         i.e. to prevent the use of the mac address of the interface.

    tgt_mac: allow limiting the effect of the DoS to a specific host,
         by sending the "invalidating RA" only to its mac address.
    """
    ...

def NDP_Attack_Fake_Router(ra, iface=..., mac_src_filter=..., ip_src_filter=...): # -> None:
    """
    The purpose of this function is to send provided RA message at layer 2
    (i.e. providing a packet starting with IPv6 will not work) in response
    to received RS messages. In the end, the function is a simple wrapper
    around sendp() that monitor the link for RS messages.

    It is probably better explained with an example:

      >>> ra  = Ether()/IPv6()/ICMPv6ND_RA()
      >>> ra /= ICMPv6NDOptPrefixInfo(prefix="2001:db8:1::", prefixlen=64)
      >>> ra /= ICMPv6NDOptPrefixInfo(prefix="2001:db8:2::", prefixlen=64)
      >>> ra /= ICMPv6NDOptSrcLLAddr(lladdr="00:11:22:33:44:55")
      >>> NDP_Attack_Fake_Router(ra, iface="eth0")
      Fake RA sent in response to RS from fe80::213:58ff:fe8c:b573
      Fake RA sent in response to RS from fe80::213:72ff:fe8c:b9ae
      ...

    Following arguments can be used to change the behavior:

      ra: the RA message to send in response to received RS message.

      iface: a specific interface (e.g. "eth0") of the system on which the
             DoS should be launched. If none is provided, conf.iface is
             used.

      mac_src_filter: a mac address (e.g "00:13:72:8c:b5:69") to filter on.
         Only RS messages received from this source will trigger a reply.
         Note that no changes to provided RA is done which imply that if
         you intend to target only the source of the RS using this option,
         you will have to set the Ethernet destination address to the same
         value in your RA.
         The default value for this parameter is None: no filtering on the
         source of RS is done.

    ip_src_filter: an IPv6 address (e.g. fe80::21e:bff:fe4e:3b2) to filter
         on. Only RS messages received from this source address will trigger
         replies. Same comment as for previous argument apply: if you use
         the option, you will probably want to set a specific Ethernet
         destination address in the RA.
    """
    ...

