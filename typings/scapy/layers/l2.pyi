"""
This type stub file was generated by pyright.
"""

from scapy.ansmachine import AnsweringMachine
from scapy.compat import Any, Callable, List, Optional, Tuple, Type, Union
from scapy.config import conf
from scapy import consts
from scapy.fields import IntEnumField, MACField
from scapy.packet import Packet
from scapy.plist import PacketList, QueryAnswer, SndRcvList, _PacketList
from scapy.interfaces import NetworkInterface

"""
Classes and functions for layer 2 protocols.
"""
if conf.route is None:
    ...
_ResolverCallable = Callable[[Packet, Packet], Optional[str]]
class Neighbor:
    def __init__(self) -> None:
        ...
    
    def register_l3(self, l2: Type[Packet], l3: Type[Packet], resolve_method: _ResolverCallable) -> None:
        ...
    
    def resolve(self, l2inst: Ether, l3inst: Packet) -> Optional[str]:
        ...
    
    def __repr__(self) -> str:
        ...
    


_arp_cache = ...
@conf.commands.register
def getmacbyip(ip: str, chainCC: int = ...) -> Optional[str]:
    """Return MAC address corresponding to a given IP address"""
    ...

class DestMACField(MACField):
    def __init__(self, name: str) -> None:
        ...
    
    def i2h(self, pkt: Optional[Ether], x: Optional[str]) -> str:
        ...
    
    def i2m(self, pkt: Optional[Ether], x: Optional[str]) -> bytes:
        ...
    


class SourceMACField(MACField):
    __slots__ = ...
    def __init__(self, name: str, getif: Optional[Any] = ...) -> None:
        ...
    
    def i2h(self, pkt: Optional[Packet], x: Optional[str]) -> str:
        ...
    
    def i2m(self, pkt: Optional[Ether], x: Optional[Any]) -> bytes:
        ...
    


class Ether(Packet):
    name = ...
    fields_desc = ...
    __slots__ = ...
    def hashret(self) -> bytes:
        ...
    
    def answers(self, other: Packet) -> int:
        ...
    
    def mysummary(self) -> str:
        ...
    
    @classmethod
    def dispatch_hook(cls, _pkt: Optional[bytes] = ..., *args: Any, **kargs: Any) -> Type[Packet]:
        ...
    


class Dot3(Packet):
    name = ...
    fields_desc = ...
    def extract_padding(self, s: bytes) -> Tuple[bytes, bytes]:
        ...
    
    def answers(self, other: Ether) -> int:
        ...
    
    def mysummary(self) -> str:
        ...
    
    @classmethod
    def dispatch_hook(cls, _pkt: Optional[Any] = ..., *args: Any, **kargs: Any) -> Type[Packet]:
        ...
    


class LLC(Packet):
    name = ...
    fields_desc = ...


def l2_register_l3(l2: Packet, l3: Packet) -> Optional[str]:
    ...

class CookedLinux(Packet):
    name = ...
    fields_desc = ...


class MPacketPreamble(Packet):
    name = ...
    fields_desc = ...


class SNAP(Packet):
    name = ...
    fields_desc = ...


class Dot1Q(Packet):
    name = ...
    aliastypes = ...
    fields_desc = ...
    def answers(self, other: Packet) -> int:
        ...
    
    def default_payload_class(self, pay: bytes) -> Type[Packet]:
        ...
    
    def extract_padding(self, s: bytes) -> Tuple[bytes, Optional[bytes]]:
        ...
    
    def mysummary(self) -> str:
        ...
    


class STP(Packet):
    name = ...
    fields_desc = ...


class ARP(Packet):
    name = ...
    fields_desc = ...
    def hashret(self) -> bytes:
        ...
    
    def answers(self, other: Packet) -> int:
        ...
    
    def route(self) -> Tuple[Union[NetworkInterface, str, None], Optional[str], Optional[str]]:
        ...
    
    def extract_padding(self, s: bytes) -> Tuple[bytes, bytes]:
        ...
    
    def mysummary(self) -> str:
        ...
    


def l2_register_l3_arp(l2: Type[Packet], l3: Type[Packet]) -> Optional[str]:
    ...

class GRErouting(Packet):
    name = ...
    fields_desc = ...


class GRE(Packet):
    name = ...
    deprecated_fields = ...
    fields_desc = ...
    @classmethod
    def dispatch_hook(cls, _pkt: Optional[Any] = ..., *args: Any, **kargs: Any) -> Type[Packet]:
        ...
    
    def post_build(self, p: bytes, pay: bytes) -> bytes:
        ...
    


class GRE_PPTP(GRE):
    """
    Enhanced GRE header used with PPTP
    RFC 2637
    """
    name = ...
    deprecated_fields = ...
    fields_desc = ...
    def post_build(self, p: bytes, pay: bytes) -> bytes:
        ...
    


class LoIntEnumField(IntEnumField):
    def m2i(self, pkt: Optional[Packet], x: int) -> int:
        ...
    
    def i2m(self, pkt: Optional[Packet], x: Union[List[int], int, None]) -> int:
        ...
    


LOOPBACK_TYPES = ...
class Loopback(Packet):
    r"""\*BSD loopback layer"""
    name = ...
    if consts.OPENBSD:
        fields_desc = ...
    else:
        fields_desc = ...
    __slots__ = ...


class Dot1AD(Dot1Q):
    name = ...


@conf.commands.register
def arpcachepoison(target: str, victim: str, interval: int = ...) -> None:
    """Poison target's cache with (your MAC,victim's IP) couple
arpcachepoison(target, victim, [interval=60]) -> None
"""
    ...

class ARPingResult(SndRcvList):
    def __init__(self, res: Optional[Union[_PacketList[QueryAnswer], List[QueryAnswer]]] = ..., name: str = ..., stats: Optional[List[Type[Packet]]] = ...) -> None:
        ...
    
    def show(self, *args: Any, **kwargs: Any) -> None:
        """
        Print the list of discovered MAC addresses.
        """
        ...
    


@conf.commands.register
def arping(net: str, timeout: int = ..., cache: int = ..., verbose: Optional[int] = ..., **kargs: Any) -> Tuple[ARPingResult, PacketList]:
    """Send ARP who-has requests to determine which hosts are up
arping(net, [cache=0,] [iface=conf.iface,] [verbose=conf.verb]) -> None
Set cache=True if you want arping to modify internal ARP-Cache"""
    ...

@conf.commands.register
def is_promisc(ip: str, fake_bcast: str = ..., **kargs: Any) -> bool:
    """Try to guess if target is in Promisc mode. The target is provided by its ip."""
    ...

@conf.commands.register
def promiscping(net: str, timeout: int = ..., fake_bcast: str = ..., **kargs: Any) -> Tuple[ARPingResult, PacketList]:
    """Send ARP who-has requests to determine which hosts are in promiscuous mode
    promiscping(net, iface=conf.iface)"""
    ...

class ARP_am(AnsweringMachine):
    """Fake ARP Relay Daemon (farpd)

    example:
    To respond to an ARP request for 192.168.100 replying on the
    ingress interface::

      farpd(IP_addr='192.168.1.100',ARP_addr='00:01:02:03:04:05')

    To respond on a different interface add the interface parameter::

      farpd(IP_addr='192.168.1.100',ARP_addr='00:01:02:03:04:05',iface='eth0')

    To respond on ANY arp request on an interface with mac address ARP_addr::

      farpd(ARP_addr='00:01:02:03:04:05',iface='eth1')

    To respond on ANY arp request with my mac addr on the given interface::

      farpd(iface='eth1')

    Optional Args::

     inter=<n>   Interval in seconds between ARP replies being sent

    """
    function_name = ...
    filter = ...
    send_function = ...
    def parse_options(self, IP_addr: Optional[str] = ..., ARP_addr: Optional[str] = ...) -> None:
        ...
    
    def is_request(self, req: Ether) -> bool:
        ...
    
    def make_reply(self, req: Ether) -> Ether:
        ...
    
    def send_reply(self, reply: ARP) -> None:
        ...
    
    def print_reply(self, req: Ether, reply: Ether) -> None:
        ...
    


@conf.commands.register
def etherleak(target: str, **kargs: Any) -> Tuple[SndRcvList, PacketList]:
    """Exploit Etherleak flaw"""
    ...

@conf.commands.register
def arpleak(target: str, plen: int = ..., hwlen: int = ..., **kargs: Any) -> Tuple[SndRcvList, PacketList]:
    """Exploit ARP leak flaws, like NetBSD-SA2017-002.

https://ftp.netbsd.org/pub/NetBSD/security/advisories/NetBSD-SA2017-002.txt.asc

    """
    ...

