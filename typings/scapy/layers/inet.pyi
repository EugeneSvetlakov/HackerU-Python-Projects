"""
This type stub file was generated by pyright.
"""

from scapy.ansmachine import AnsweringMachine
from scapy.config import conf
from scapy.fields import DestField, IPField, IntField, StrField
from scapy.packet import Packet
from scapy.volatile import VolatileValue
from scapy.plist import SndRcvList
from scapy.automaton import ATMT, Automaton

"""
IPv4 (Internet Protocol v4).
"""
class IPTools:
    """Add more powers to a class with an "src" attribute."""
    __slots__ = ...
    def whois(self): # -> None:
        """whois the source and print the output"""
        ...
    
    def ottl(self): # -> int:
        ...
    
    def hops(self):
        ...
    


_ip_options_names = ...
class _IPOption_HDR(Packet):
    fields_desc = ...


class IPOption(Packet):
    name = ...
    fields_desc = ...
    def extract_padding(self, p): # -> tuple[Literal[b''], Unknown]:
        ...
    
    registered_ip_options = ...
    @classmethod
    def register_variant(cls): # -> None:
        ...
    
    @classmethod
    def dispatch_hook(cls, pkt=..., *args, **kargs): # -> Type[Self@IPOption]:
        ...
    


class IPOption_EOL(IPOption):
    name = ...
    option = ...
    fields_desc = ...


class IPOption_NOP(IPOption):
    name = ...
    option = ...
    fields_desc = ...


class IPOption_Security(IPOption):
    name = ...
    copy_flag = ...
    option = ...
    fields_desc = ...


class IPOption_RR(IPOption):
    name = ...
    option = ...
    fields_desc = ...
    def get_current_router(self):
        ...
    


class IPOption_LSRR(IPOption_RR):
    name = ...
    copy_flag = ...
    option = ...


class IPOption_SSRR(IPOption_RR):
    name = ...
    copy_flag = ...
    option = ...


class IPOption_Stream_Id(IPOption):
    name = ...
    copy_flag = ...
    option = ...
    fields_desc = ...


class IPOption_MTU_Probe(IPOption):
    name = ...
    option = ...
    fields_desc = ...


class IPOption_MTU_Reply(IPOption_MTU_Probe):
    name = ...
    option = ...


class IPOption_Traceroute(IPOption):
    name = ...
    option = ...
    fields_desc = ...


class IPOption_Timestamp(IPOption):
    name = ...
    optclass = ...
    option = ...
    fields_desc = ...
    def post_build(self, p, pay):
        ...
    


class IPOption_Address_Extension(IPOption):
    name = ...
    copy_flag = ...
    option = ...
    fields_desc = ...


class IPOption_Router_Alert(IPOption):
    name = ...
    copy_flag = ...
    option = ...
    fields_desc = ...


class IPOption_SDBM(IPOption):
    name = ...
    copy_flag = ...
    option = ...
    fields_desc = ...


TCPOptions = ...
class RandTCPOptions(VolatileValue):
    def __init__(self, size=...) -> None:
        ...
    
    def __bytes__(self): # -> bytes:
        ...
    


class TCPOptionsField(StrField):
    islist = ...
    def getfield(self, pkt, s): # -> tuple[Unknown, Unknown]:
        ...
    
    def m2i(self, pkt, x):
        ...
    
    def i2h(self, pkt, x): # -> list[Unknown]:
        ...
    
    def i2m(self, pkt, x):
        ...
    
    def randval(self): # -> RandTCPOptions:
        ...
    


class ICMPTimeStampField(IntField):
    re_hmsm = ...
    def i2repr(self, pkt, val): # -> str:
        ...
    
    def any2i(self, pkt, val): # -> int:
        ...
    


class DestIPField(IPField, DestField):
    bindings = ...
    def __init__(self, name, default) -> None:
        ...
    
    def i2m(self, pkt, x): # -> bytes:
        ...
    
    def i2h(self, pkt, x): # -> str:
        ...
    


class IP(Packet, IPTools):
    __slots__ = ...
    name = ...
    fields_desc = ...
    def post_build(self, p, pay):
        ...
    
    def extract_padding(self, s): # -> tuple[Unknown, Literal[b'']] | tuple[Unknown, Unknown]:
        ...
    
    def route(self):
        ...
    
    def hashret(self): # -> bytes | Any:
        ...
    
    def answers(self, other):
        ...
    
    def mysummary(self): # -> str:
        ...
    
    def fragment(self, fragsize=...):
        """Fragment IP datagrams"""
        ...
    


def in4_chksum(proto, u, p):
    """
    As Specified in RFC 2460 - 8.1 Upper-Layer Checksums

    Performs IPv4 Upper Layer checksum computation. Provided parameters are:
    - 'proto' : value of upper layer protocol
    - 'u'  : IP upper layer instance
    - 'p'  : the payload of the upper layer provided as a string
    """
    ...

class TCP(Packet):
    name = ...
    fields_desc = ...
    def post_build(self, p, pay):
        ...
    
    def hashret(self): # -> bytes | Any:
        ...
    
    def answers(self, other):
        ...
    
    def mysummary(self): # -> str:
        ...
    


class UDP(Packet):
    name = ...
    fields_desc = ...
    def post_build(self, p, pay):
        ...
    
    def extract_padding(self, s): # -> tuple[Unknown, Unknown]:
        ...
    
    def hashret(self): # -> bytes | Any:
        ...
    
    def answers(self, other): # -> bool | int | Any:
        ...
    
    def mysummary(self): # -> str:
        ...
    


icmptypes = ...
icmpcodes = ...
class ICMP(Packet):
    name = ...
    fields_desc = ...
    def post_build(self, p, pay):
        ...
    
    def hashret(self): # -> bytes | Any:
        ...
    
    def answers(self, other): # -> Literal[0, 1]:
        ...
    
    def guess_payload_class(self, payload): # -> Type[IPerror] | None:
        ...
    
    def mysummary(self): # -> str:
        ...
    


class IPerror(IP):
    name = ...
    def answers(self, other):
        ...
    
    def mysummary(self): # -> str:
        ...
    


class TCPerror(TCP):
    name = ...
    def answers(self, other):
        ...
    
    def mysummary(self): # -> str:
        ...
    


class UDPerror(UDP):
    name = ...
    def answers(self, other): # -> Literal[0, 1]:
        ...
    
    def mysummary(self): # -> str:
        ...
    


class ICMPerror(ICMP):
    name = ...
    def answers(self, other): # -> Literal[0, 1]:
        ...
    
    def mysummary(self): # -> str:
        ...
    


def inet_register_l3(l2, l3):
    ...

@conf.commands.register
def fragment(pkt, fragsize=...): # -> list[Unknown]:
    """Fragment a big IP datagram"""
    ...

@conf.commands.register
def overlap_frag(p, overlap, fragsize=..., overlap_fragsize=...): # -> list[Unknown]:
    """Build overlapping fragments to bypass NIPS

p:                the original packet
overlap:          the overlapping data
fragsize:         the fragment size of the packet
overlap_fragsize: the fragment size of the overlapping packet"""
    ...

@conf.commands.register
def defrag(plist): # -> PacketList | tuple[PacketList, PacketList, PacketList]:
    """defrag(plist) -> ([not fragmented], [defragmented],
                  [ [bad fragments], [bad fragments], ... ])"""
    ...

@conf.commands.register
def defragment(plist): # -> PacketList | tuple[PacketList, PacketList, PacketList]:
    """defragment(plist) -> plist defragmented as much as possible """
    ...

class TracerouteResult(SndRcvList):
    __slots__ = ...
    def __init__(self, res=..., name=..., stats=...) -> None:
        ...
    
    def show(self):
        ...
    
    def get_trace(self): # -> dict[Unknown, Unknown]:
        ...
    
    def trace3D(self, join=...): # -> None:
        """Give a 3D representation of the traceroute.
        right button: rotate the scene
        middle button: zoom
        shift-left button: move the scene
        left button on a ball: toggle IP displaying
        double-click button on a ball: scan ports 21,22,23,25,80 and 443 and display the result"""
        ...
    
    def trace3D_notebook(self): # -> None:
        """Same than trace3D, used when ran from Jupyther notebooks"""
        class IPsphere(vpython.sphere):
            ...
        
        
    
    def world_trace(self): # -> list[Unknown]:
        """Display traceroute results on a world map."""
        ...
    
    def make_graph(self, ASres=..., padding=...):
        ...
    
    def graph(self, ASres=..., padding=..., **kargs):
        """x.graph(ASres=conf.AS_resolver, other args):
        ASres=None          : no AS resolver => no clustering
        ASres=AS_resolver() : default whois AS resolver (riswhois.ripe.net)
        ASres=AS_resolver_cymru(): use whois.cymru.com whois database
        ASres=AS_resolver(server="whois.ra.net")
        type: output type (svg, ps, gif, jpg, etc.), passed to dot's "-T" option  # noqa: E501
        target: filename or redirect. Defaults pipe to Imagemagick's display program  # noqa: E501
        prog: which graphviz program to use"""
        ...
    


@conf.commands.register
def traceroute(target, dport=..., minttl=..., maxttl=..., sport=..., l4=..., filter=..., timeout=..., verbose=..., **kargs): # -> tuple[TracerouteResult, Any | Unknown]:
    """Instant TCP traceroute

       :param target:  hostnames or IP addresses
       :param dport:   TCP destination port (default is 80)
       :param minttl:  minimum TTL (default is 1)
       :param maxttl:  maximum TTL (default is 30)
       :param sport:   TCP source port (default is random)
       :param l4:      use a Scapy packet instead of TCP
       :param filter:  BPF filter applied to received packets
       :param timeout: time to wait for answers (default is 2s)
       :param verbose: detailed output
       :return: an TracerouteResult, and a list of unanswered packets"""
    ...

@conf.commands.register
def traceroute_map(ips, **kargs): # -> list[Unknown]:
    """Util function to call traceroute on multiple targets, then
    show the different paths on a map.

    :param ips: a list of IPs on which traceroute will be called
    :param kargs: (optional) kwargs, passed to traceroute
    """
    ...

class TCP_client(Automaton):
    """
    Creates a TCP Client Automaton.
    This automaton will handle TCP 3-way handshake.

    Usage: the easiest usage is to use it as a SuperSocket.
        >>> a = TCP_client.tcplink(HTTP, "www.google.com", 80)
        >>> a.send(HTTPRequest())
        >>> a.recv()

    :param ip: the ip to connect to
    :param port:
    """
    def parse_args(self, ip, port, *args, **kargs): # -> None:
        ...
    
    def master_filter(self, pkt): # -> Literal[False]:
        ...
    
    @ATMT.state(initial=1)
    def START(self): # -> None:
        ...
    
    @ATMT.state()
    def SYN_SENT(self): # -> None:
        ...
    
    @ATMT.state()
    def ESTABLISHED(self): # -> None:
        ...
    
    @ATMT.state()
    def LAST_ACK(self): # -> None:
        ...
    
    @ATMT.state(final=1)
    def CLOSED(self): # -> None:
        ...
    
    @ATMT.state(stop=1)
    def STOP(self): # -> None:
        ...
    
    @ATMT.state()
    def STOP_SENT_FIN_ACK(self): # -> None:
        ...
    
    @ATMT.condition(START)
    def connect(self): # -> NoReturn:
        ...
    
    @ATMT.action(connect)
    def send_syn(self): # -> None:
        ...
    
    @ATMT.receive_condition(SYN_SENT)
    def synack_received(self, pkt): # -> None:
        ...
    
    @ATMT.action(synack_received)
    def send_ack_of_synack(self, pkt): # -> None:
        ...
    
    @ATMT.receive_condition(ESTABLISHED)
    def incoming_data_received(self, pkt): # -> None:
        ...
    
    @ATMT.action(incoming_data_received)
    def receive_data(self, pkt): # -> None:
        ...
    
    @ATMT.ioevent(ESTABLISHED, name="tcp", as_supersocket="tcplink")
    def outgoing_data_received(self, fd): # -> NoReturn:
        ...
    
    @ATMT.action(outgoing_data_received)
    def send_data(self, d): # -> None:
        ...
    
    @ATMT.receive_condition(ESTABLISHED)
    def reset_received(self, pkt): # -> None:
        ...
    
    @ATMT.receive_condition(ESTABLISHED)
    def fin_received(self, pkt): # -> None:
        ...
    
    @ATMT.action(fin_received)
    def send_finack(self, pkt): # -> None:
        ...
    
    @ATMT.receive_condition(LAST_ACK)
    def ack_of_fin_received(self, pkt): # -> None:
        ...
    
    @ATMT.condition(STOP)
    def stop_requested(self): # -> NoReturn:
        ...
    
    @ATMT.action(stop_requested)
    def stop_send_finack(self): # -> None:
        ...
    
    @ATMT.receive_condition(STOP_SENT_FIN_ACK)
    def stop_fin_received(self, pkt): # -> None:
        ...
    
    @ATMT.action(stop_fin_received)
    def stop_send_ack(self, pkt): # -> None:
        ...
    
    @ATMT.timeout(SYN_SENT, 1)
    def syn_ack_timeout(self): # -> NoReturn:
        ...
    
    @ATMT.timeout(STOP_SENT_FIN_ACK, 1)
    def stop_ack_timeout(self): # -> NoReturn:
        ...
    


@conf.commands.register
def report_ports(target, ports):
    """portscan a target and output a LaTeX table
report_ports(target, ports) -> string"""
    ...

@conf.commands.register
def IPID_count(lst, funcID=..., funcpres=...): # -> None:
    """Identify IP id values classes in a list of packets

lst:      a list of packets
funcID:   a function that returns IP id values
funcpres: a function used to summarize packets"""
    ...

@conf.commands.register
def fragleak(target, sport=..., dport=..., timeout=..., onlyasc=..., count=...):
    ...

@conf.commands.register
def fragleak2(target, timeout=..., onlyasc=..., count=...):
    ...

class ICMPEcho_am(AnsweringMachine):
    """Responds to ICMP Echo-Requests (ping)"""
    function_name = ...
    def is_request(self, req): # -> bool:
        ...
    
    def print_reply(self, req, reply): # -> None:
        ...
    
    def make_reply(self, req):
        ...
    


if conf.ipv6_enabled:
    ...
