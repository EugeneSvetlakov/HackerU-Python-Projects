"""
This type stub file was generated by pyright.
"""

import os
import socket
from scapy.compat import Any, Dict, List, NoReturn, Optional, Tuple, Type, Union
from scapy.interfaces import InterfaceProvider, NetworkInterface
from scapy.packet import Packet
from scapy.supersocket import SuperSocket

"""
Linux specific functions.
"""
SIOCGIFHWADDR = ...
SIOCGIFADDR = ...
SIOCGIFNETMASK = ...
SIOCGIFNAME = ...
SIOCSIFLINK = ...
SIOCGIFCONF = ...
SIOCGIFFLAGS = ...
SIOCSIFFLAGS = ...
SIOCGIFINDEX = ...
SIOCGIFCOUNT = ...
SIOCGSTAMP = ...
IFF_UP = ...
IFF_BROADCAST = ...
IFF_DEBUG = ...
IFF_LOOPBACK = ...
IFF_POINTOPOINT = ...
IFF_NOTRAILERS = ...
IFF_RUNNING = ...
IFF_NOARP = ...
IFF_PROMISC = ...
PACKET_ADD_MEMBERSHIP = ...
PACKET_DROP_MEMBERSHIP = ...
PACKET_RECV_OUTPUT = ...
PACKET_RX_RING = ...
PACKET_STATISTICS = ...
PACKET_MR_MULTICAST = ...
PACKET_MR_PROMISC = ...
PACKET_MR_ALLMULTI = ...
RTF_UP = ...
RTF_REJECT = ...
PACKET_HOST = ...
PACKET_BROADCAST = ...
PACKET_MULTICAST = ...
PACKET_OTHERHOST = ...
PACKET_OUTGOING = ...
PACKET_LOOPBACK = ...
PACKET_USER = ...
PACKET_KERNEL = ...
PACKET_AUXDATA = ...
PACKET_FASTROUTE = ...
def get_if_raw_addr(iff: Union[NetworkInterface, str]) -> bytes:
    r"""
    Return the raw IPv4 address of an interface.
    If unavailable, returns b"\0\0\0\0"
    """
    ...

def attach_filter(sock: socket.socket, bpf_filter: str, iface: Union[NetworkInterface, str]) -> None:
    """
    Compile bpf filter and attach it to a socket

    :param sock: the python socket
    :param bpf_filter: the bpf string filter to compile
    :param iface: the interface used to compile
    """
    ...

def set_promisc(s: socket.socket, iff: Union[NetworkInterface, str], val: int = ...) -> None:
    ...

def get_alias_address(iface_name: str, ip_mask: int, gw_str: str, metric: int) -> Optional[Tuple[int, int, str, str, str, int]]:
    """
    Get the correct source IP address of an interface alias
    """
    ...

def read_routes() -> List[Tuple[int, int, str, str, str, int]]:
    ...

def in6_getifaddr() -> List[Tuple[str, int, str]]:
    """
    Returns a list of 3-tuples of the form (addr, scope, iface) where
    'addr' is the address of scope 'scope' associated to the interface
    'iface'.

    This is the list of all addresses of all interfaces available on
    the system.
    """
    ...

def read_routes6() -> List[Tuple[str, int, str, str, List[str], int]]:
    ...

def get_if_index(iff: Union[NetworkInterface, str]) -> int:
    ...

class LinuxInterfaceProvider(InterfaceProvider):
    name = ...
    def load(self) -> Dict[str, NetworkInterface]:
        ...
    


if os.uname()[4] in ['x86_64', 'aarch64']:
    def get_last_packet_timestamp(sock: socket.socket) -> float:
        ...
    
else:
    def get_last_packet_timestamp(sock: socket.socket) -> float:
        ...
    
class L2Socket(SuperSocket):
    desc = ...
    def __init__(self, iface: Optional[Union[str, NetworkInterface]] = ..., type: int = ..., promisc: Optional[Any] = ..., filter: Optional[Any] = ..., nofilter: int = ..., monitor: Optional[Any] = ...) -> None:
        ...
    
    def close(self) -> None:
        ...
    
    def recv_raw(self, x: int = ...) -> Tuple[Optional[Type[Packet]], Optional[bytes], Optional[float]]:
        """Receives a packet, then returns a tuple containing (cls, pkt_data, time)"""
        ...
    
    def send(self, x: Packet) -> int:
        ...
    


class L2ListenSocket(L2Socket):
    desc = ...
    def send(self, x: Packet) -> NoReturn:
        ...
    


class L3PacketSocket(L2Socket):
    desc = ...
    def recv(self, x: int = ...) -> Optional[Packet]:
        ...
    
    def send(self, x: Packet) -> int:
        ...
    


class VEthPair:
    """
    encapsulates a virtual Ethernet interface pair
    """
    def __init__(self, iface_name: str, peer_name: str) -> None:
        ...
    
    def iface(self) -> str:
        ...
    
    def peer(self) -> str:
        ...
    
    def setup(self) -> None:
        """
        create veth pair links
        :raises subprocess.CalledProcessError if operation fails
        """
        ...
    
    def destroy(self) -> None:
        """
        remove veth pair links
        :raises subprocess.CalledProcessError if operation fails
        """
        ...
    
    def up(self) -> None:
        """
        set veth pair links up
        :raises subprocess.CalledProcessError if operation fails
        """
        ...
    
    def down(self) -> None:
        """
        set veth pair links down
        :raises subprocess.CalledProcessError if operation fails
        """
        ...
    
    def __enter__(self) -> VEthPair:
        ...
    
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
        ...
    


