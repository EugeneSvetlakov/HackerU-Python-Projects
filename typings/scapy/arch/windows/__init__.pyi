"""
This type stub file was generated by pyright.
"""

import os
import platform as platform_lib
import socket
import subprocess as sp
import struct
import warnings
import scapy.modules.six as six
from __future__ import absolute_import, print_function
from glob import glob
from scapy.arch.windows.structures import GetAdaptersAddresses, GetIpForwardTable, GetIpForwardTable2, _windows_title, get_service_status
from scapy.consts import WINDOWS, WINDOWS_XP
from scapy.config import ProgPath, conf
from scapy.error import Scapy_Exception, log_interactive, log_loading, log_runtime, warning
from scapy.interfaces import InterfaceProvider, NetworkInterface, dev_from_index, network_name, resolve_iface
from scapy.pton_ntop import inet_ntop, inet_pton
from scapy.utils import atol, itom, mac2str, str2mac
from scapy.utils6 import construct_source_candidate_set, in6_getscope
from scapy.data import ARPHDR_ETHER, load_manuf
from scapy.modules.six.moves import input, winreg
from scapy.compat import plain_str
from scapy.supersocket import SuperSocket
from scapy.arch import libpcap
from scapy.arch.libpcap import NPCAP_PATH, PCAP_IF_UP

"""
Customizations needed to support Microsoft Windows.
"""
NPCAP_LOOPBACK_NAME = ...
if conf.use_npcap:
    ...
else:
    ...
if nothasattr(socket, 'IPPROTO_IPIP'):
    ...
if nothasattr(socket, 'IP_RECVTTL'):
    ...
if nothasattr(socket, 'IPV6_HDRINCL'):
    ...
if nothasattr(socket, 'IPPROTO_IPV6'):
    ...
if nothasattr(socket, 'SOL_IPV6'):
    ...
if nothasattr(socket, 'IPPROTO_GRE'):
    ...
if nothasattr(socket, 'IPPROTO_AH'):
    ...
if nothasattr(socket, 'IPPROTO_ESP'):
    ...
_WlanHelper = ...
def win_find_exe(filename, installsubdir=..., env=...):
    """Find executable in current dir, system path or in the
    given ProgramFiles subdir, and retuen its absolute path.
    """
    ...

class WinProgPath(ProgPath):
    def __init__(self) -> None:
        ...
    


if conf.prog.tcpdump and conf.use_npcap:
    def test_windump_npcap(): # -> bool:
        """Return whether windump version is correct or not"""
        ...
    
    windump_ok = ...
def get_windows_if_list(extended=...): # -> list[dict[str, Unknown | str | int | list[Unknown]]]:
    """Returns windows interfaces through GetAdaptersAddresses.

    params:
     - extended: include anycast and multicast IPv6 (default False)"""
    ...

class NetworkInterface_Win(NetworkInterface):
    """A network interface of your local host"""
    def __init__(self, provider, data=...) -> None:
        ...
    
    def update(self, data):
        """Update info about a network interface according
        to a given dictionary. Such data is provided by get_windows_if_list
        """
        ...
    
    def mode(self): # -> str:
        """Get the interface operation mode.
        Only available with Npcap."""
        ...
    
    def ismonitor(self): # -> bool:
        """Returns True if the interface is in monitor mode.
        Only available with Npcap."""
        ...
    
    def setmonitor(self, enable=...): # -> bool:
        """Alias for setmode('monitor') or setmode('managed')
        Only available with Npcap"""
        ...
    
    def availablemodes(self): # -> list[str]:
        """Get all available interface modes.
        Only available with Npcap."""
        ...
    
    def setmode(self, mode): # -> Literal[True]:
        """Set the interface mode. It can be:
        - 0 or managed: Managed Mode (aka "Extensible Station Mode")
        - 1 or monitor: Monitor Mode (aka "Network Monitor Mode")
        - 2 or master: Master Mode (aka "Extensible Access Point")
              (supported from Windows 7 and later)
        - 3 or wfd_device: The Wi-Fi Direct Device operation mode
              (supported from Windows 8 and later)
        - 4 or wfd_owner: The Wi-Fi Direct Group Owner operation mode
              (supported from Windows 8 and later)
        - 5 or wfd_client: The Wi-Fi Direct Client operation mode
              (supported from Windows 8 and later)
        Only available with Npcap."""
        ...
    
    def channel(self): # -> int:
        """Get the channel of the interface.
        Only available with Npcap."""
        ...
    
    def setchannel(self, channel): # -> Literal[True]:
        """Set the channel of the interface (1-14):
        Only available with Npcap."""
        ...
    
    def frequence(self): # -> int:
        """Get the frequence of the interface.
        Only available with Npcap."""
        ...
    
    def setfrequence(self, freq): # -> Literal[True]:
        """Set the channel of the interface (1-14):
        Only available with Npcap."""
        ...
    
    def availablemodulations(self): # -> list[str]:
        """Get all available 802.11 interface modulations.
        Only available with Npcap."""
        ...
    
    def modulation(self): # -> str:
        """Get the 802.11 modulation of the interface.
        Only available with Npcap."""
        ...
    
    def setmodulation(self, modu): # -> Literal[True]:
        """Set the interface modulation. It can be:
           - 0: dsss
           - 1: fhss
           - 2: irbaseband
           - 3: ofdm
           - 4: hrdss
           - 5: erp
           - 6: ht
           - 7: vht
           - 8: ihv
           - 9: mimo-ofdm
           - 10: mimo-ofdm
           - the value directly
        Only available with Npcap."""
        ...
    


class WindowsInterfacesProvider(InterfaceProvider):
    name = ...
    libpcap = ...
    def load(self, NetworkInterface_Win=...):
        ...
    
    def reload(self): # -> dict[Unknown, Unknown]:
        """Reload interface list"""
        ...
    


def get_ips(v6=...): # -> dict[Unknown, Unknown]:
    """Returns all available IPs matching to interfaces, using the windows system.
    Should only be used as a WinPcapy fallback."""
    ...

def get_if_raw_addr(iff): # -> bytes | None:
    """Return the raw IPv4 address of interface"""
    ...

def get_ip_from_name(ifname, v6=...): # -> str:
    """Backward compatibility: indirectly calls get_ips
    Deprecated."""
    ...

def pcap_service_name(): # -> Literal['npcap', 'npf']:
    """Return the pcap adapter service's name"""
    ...

def pcap_service_status():
    """Returns whether the windows pcap adapter is running or not"""
    ...

def pcap_service_start(askadmin=...): # -> bool:
    """Starts the pcap adapter. Will ask for admin. Returns True if success"""
    ...

def pcap_service_stop(askadmin=...): # -> bool:
    """Stops the pcap adapter. Will ask for admin. Returns True if success"""
    ...

if conf.use_pcap:
    _orig_open_pcap = libpcap.open_pcap
    def open_pcap(iface, *args, **kargs): # -> _orig_open_pcap:
        """open_pcap: Windows routine for creating a pcap from an interface.
        This function is also responsible for detecting monitor mode.
        """
        ...
    
def get_if_raw_hwaddr(iface): # -> tuple[Literal[1], bytes]:
    ...

def read_routes(): # -> list[Unknown]:
    ...

def in6_getifaddr(): # -> list[Unknown]:
    """
    Returns all IPv6 addresses found on the computer
    """
    ...

def read_routes6(): # -> list[Unknown]:
    ...

class _NotAvailableSocket(SuperSocket):
    desc = ...
    def __init__(self, *args, **kargs) -> None:
        ...
    


