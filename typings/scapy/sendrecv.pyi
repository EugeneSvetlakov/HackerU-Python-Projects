"""
This type stub file was generated by pyright.
"""

from scapy.compat import Any, Callable, Dict, List, Optional, Tuple, Type, Union
from scapy.config import conf
from scapy.interfaces import _GlobInterfaceType
from scapy.packet import Packet
from scapy.plist import PacketList, SndRcvList, _PacketIterable
from scapy.sessions import DefaultSession
from scapy.supersocket import SuperSocket

"""
Functions to send and receive packets.
"""
if conf.route is None:
    ...
class debug:
    recv = ...
    sent = ...
    match = ...
    crashed_on: Optional[Tuple[Type[Packet], bytes]] = ...


_DOC_SNDRCV_PARAMS = ...
_GlobSessionType = Union[Type[DefaultSession], DefaultSession]
class SndRcvHandler:
    """
    Util to send/receive packets, used by sr*().
    Do not use directly.

    This matches the requests and answers.

    Notes::
      - threaded mode: enabling threaded mode will likely
        break packet timestamps, but might result in a speedup
        when sending a big amount of packets. Disabled by default
      - DEVS: store the outgoing timestamp right BEFORE sending the packet
        to avoid races that could result in negative latency. We aren't Stadia
    """
    def __init__(self, pks: SuperSocket, pkt: _PacketIterable, timeout: Optional[int] = ..., inter: int = ..., verbose: Optional[int] = ..., chainCC: bool = ..., retry: int = ..., multi: bool = ..., rcv_pks: Optional[SuperSocket] = ..., prebuild: bool = ..., _flood: Optional[Tuple[int, Callable[[], None]]] = ..., threaded: bool = ..., session: Optional[_GlobSessionType] = ...) -> None:
        ...
    
    def results(self) -> Tuple[SndRcvList, PacketList]:
        ...
    


def sndrcv(*args: Any, **kwargs: Any) -> Tuple[SndRcvList, PacketList]:
    """Scapy raw function to send a packet and receive its answer.
    WARNING: This is an internal function. Using sr/srp/sr1/srp is
    more appropriate in many cases.
    """
    ...

@conf.commands.register
def send(x: _PacketIterable, iface: Optional[_GlobInterfaceType] = ..., **kargs: Any) -> Optional[PacketList]:
    """
    Send packets at layer 3

    :param x: the packets
    :param inter: time (in s) between two packets (default 0)
    :param loop: send packet indefinetly (default 0)
    :param count: number of packets to send (default None=1)
    :param verbose: verbose mode (default None=conf.verbose)
    :param realtime: check that a packet was sent before sending the next one
    :param return_packets: return the sent packets
    :param socket: the socket to use (default is conf.L3socket(kargs))
    :param iface: the interface to send the packets on
    :param monitor: (not on linux) send in monitor mode
    :returns: None
    """
    ...

@conf.commands.register
def sendp(x: _PacketIterable, iface: Optional[_GlobInterfaceType] = ..., iface_hint: Optional[str] = ..., socket: Optional[SuperSocket] = ..., **kargs: Any) -> Optional[PacketList]:
    """
    Send packets at layer 2

    :param x: the packets
    :param inter: time (in s) between two packets (default 0)
    :param loop: send packet indefinetly (default 0)
    :param count: number of packets to send (default None=1)
    :param verbose: verbose mode (default None=conf.verbose)
    :param realtime: check that a packet was sent before sending the next one
    :param return_packets: return the sent packets
    :param socket: the socket to use (default is conf.L3socket(kargs))
    :param iface: the interface to send the packets on
    :param monitor: (not on linux) send in monitor mode
    :returns: None
    """
    ...

@conf.commands.register
def sendpfast(x: _PacketIterable, pps: Optional[float] = ..., mbps: Optional[float] = ..., realtime: bool = ..., loop: int = ..., file_cache: bool = ..., iface: Optional[_GlobInterfaceType] = ..., replay_args: Optional[List[str]] = ..., parse_results: bool = ...) -> Optional[Dict[str, Any]]:
    """Send packets at layer 2 using tcpreplay for performance

    :param pps:  packets per second
    :param mpbs: MBits per second
    :param realtime: use packet's timestamp, bending time with real-time value
    :param loop: number of times to process the packet list
    :param file_cache: cache packets in RAM instead of reading from
        disk at each iteration
    :param iface: output interface
    :param replay_args: List of additional tcpreplay args (List[str])
    :param parse_results: Return a dictionary of information
        outputted by tcpreplay (default=False)
    :returns: stdout, stderr, command used
    """
    ...

@conf.commands.register
def sr(x: _PacketIterable, promisc: Optional[bool] = ..., filter: Optional[str] = ..., iface: Optional[_GlobInterfaceType] = ..., nofilter: int = ..., *args: Any, **kargs: Any) -> Tuple[SndRcvList, PacketList]:
    """
    Send and receive packets at layer 3
    """
    ...

@conf.commands.register
def sr1(x: _PacketIterable, promisc: Optional[bool] = ..., filter: Optional[str] = ..., iface: Optional[_GlobInterfaceType] = ..., nofilter: int = ..., *args: Any, **kargs: Any) -> Optional[Packet]:
    """
    Send packets at layer 3 and return only the first answer
    """
    ...

@conf.commands.register
def srp(x: Packet, promisc: Optional[bool] = ..., iface: Optional[_GlobInterfaceType] = ..., iface_hint: Optional[str] = ..., filter: Optional[str] = ..., nofilter: int = ..., type: int = ..., *args: Any, **kargs: Any) -> Tuple[SndRcvList, PacketList]:
    """
    Send and receive packets at layer 2
    """
    ...

@conf.commands.register
def srp1(*args: Packet, **kargs: Any) -> Optional[Packet]:
    """
    Send and receive packets at layer 2 and return only the first answer
    """
    ...

@conf.commands.register
def srloop(pkts: _PacketIterable, *args: Any, **kargs: Any) -> Tuple[SndRcvList, PacketList]:
    """
    Send a packet at layer 3 in loop and print the answer each time
    srloop(pkts, [prn], [inter], [count], ...) --> None
    """
    ...

@conf.commands.register
def srploop(pkts: _PacketIterable, *args: Any, **kargs: Any) -> Tuple[SndRcvList, PacketList]:
    """
    Send a packet at layer 2 in loop and print the answer each time
    srloop(pkts, [prn], [inter], [count], ...) --> None
    """
    ...

def sndrcvflood(pks: SuperSocket, pkt: _PacketIterable, inter: int = ..., verbose: Optional[int] = ..., chainCC: bool = ..., timeout: Optional[int] = ...) -> Tuple[SndRcvList, PacketList]:
    """sndrcv equivalent for flooding."""
    ...

@conf.commands.register
def srflood(x: _PacketIterable, promisc: Optional[bool] = ..., filter: Optional[str] = ..., iface: Optional[_GlobInterfaceType] = ..., nofilter: Optional[bool] = ..., *args: Any, **kargs: Any) -> Tuple[SndRcvList, PacketList]:
    """Flood and receive packets at layer 3

    :param prn:      function applied to packets received
    :param unique:   only consider packets whose print
    :param nofilter: put 1 to avoid use of BPF filters
    :param filter:   provide a BPF filter
    :param iface:    listen answers only on the given interface
    """
    ...

@conf.commands.register
def sr1flood(x: _PacketIterable, promisc: Optional[bool] = ..., filter: Optional[str] = ..., iface: Optional[_GlobInterfaceType] = ..., nofilter: int = ..., *args: Any, **kargs: Any) -> Optional[Packet]:
    """Flood and receive packets at layer 3 and return only the first answer

    :param prn:      function applied to packets received
    :param verbose:  set verbosity level
    :param nofilter: put 1 to avoid use of BPF filters
    :param filter:   provide a BPF filter
    :param iface:    listen answers only on the given interface
    """
    ...

@conf.commands.register
def srpflood(x: _PacketIterable, promisc: Optional[bool] = ..., filter: Optional[str] = ..., iface: Optional[_GlobInterfaceType] = ..., iface_hint: Optional[str] = ..., nofilter: Optional[bool] = ..., *args: Any, **kargs: Any) -> Tuple[SndRcvList, PacketList]:
    """Flood and receive packets at layer 2

    :param prn:      function applied to packets received
    :param unique:   only consider packets whose print
    :param nofilter: put 1 to avoid use of BPF filters
    :param filter:   provide a BPF filter
    :param iface:    listen answers only on the given interface
    """
    ...

@conf.commands.register
def srp1flood(x: _PacketIterable, promisc: Optional[bool] = ..., filter: Optional[str] = ..., iface: Optional[_GlobInterfaceType] = ..., nofilter: int = ..., *args: Any, **kargs: Any) -> Optional[Packet]:
    """Flood and receive packets at layer 2 and return only the first answer

    :param prn:      function applied to packets received
    :param verbose:  set verbosity level
    :param nofilter: put 1 to avoid use of BPF filters
    :param filter:   provide a BPF filter
    :param iface:    listen answers only on the given interface
    """
    ...

class AsyncSniffer:
    """
    Sniff packets and return a list of packets.

    Args:
        count: number of packets to capture. 0 means infinity.
        store: whether to store sniffed packets or discard them
        prn: function to apply to each packet. If something is returned, it
             is displayed.
             --Ex: prn = lambda x: x.summary()
        session: a session = a flow decoder used to handle stream of packets.
                 --Ex: session=TCPSession
                 See below for more details.
        filter: BPF filter to apply.
        lfilter: Python function applied to each packet to determine if
                 further action may be done.
                 --Ex: lfilter = lambda x: x.haslayer(Padding)
        offline: PCAP file (or list of PCAP files) to read packets from,
                 instead of sniffing them
        quiet:   when set to True, the process stderr is discarded
                 (default: False).
        timeout: stop sniffing after a given time (default: None).
        L2socket: use the provided L2socket (default: use conf.L2listen).
        opened_socket: provide an object (or a list of objects) ready to use
                      .recv() on.
        stop_filter: Python function applied to each packet to determine if
                     we have to stop the capture after this packet.
                     --Ex: stop_filter = lambda x: x.haslayer(TCP)
        iface: interface or list of interfaces (default: None for sniffing
               on all interfaces).
        monitor: use monitor mode. May not be available on all OS
        started_callback: called as soon as the sniffer starts sniffing
                          (default: None).

    The iface, offline and opened_socket parameters can be either an
    element, a list of elements, or a dict object mapping an element to a
    label (see examples below).

    For more information about the session argument, see
    https://scapy.rtfd.io/en/latest/usage.html#advanced-sniffing-sniffing-sessions

    Examples: synchronous
      >>> sniff(filter="arp")
      >>> sniff(filter="tcp",
      ...       session=IPSession,  # defragment on-the-flow
      ...       prn=lambda x: x.summary())
      >>> sniff(lfilter=lambda pkt: ARP in pkt)
      >>> sniff(iface="eth0", prn=Packet.summary)
      >>> sniff(iface=["eth0", "mon0"],
      ...       prn=lambda pkt: "%s: %s" % (pkt.sniffed_on,
      ...                                   pkt.summary()))
      >>> sniff(iface={"eth0": "Ethernet", "mon0": "Wifi"},
      ...       prn=lambda pkt: "%s: %s" % (pkt.sniffed_on,
      ...                                   pkt.summary()))

    Examples: asynchronous
      >>> t = AsyncSniffer(iface="enp0s3")
      >>> t.start()
      >>> time.sleep(1)
      >>> print("nice weather today")
      >>> t.stop()
    """
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        ...
    
    def start(self) -> None:
        """Starts AsyncSniffer in async mode"""
        ...
    
    def stop(self, join: bool = ...) -> Optional[PacketList]:
        """Stops AsyncSniffer if not in async mode"""
        ...
    
    def join(self, *args: Any, **kwargs: Any) -> None:
        ...
    


@conf.commands.register
def sniff(*args: Any, **kwargs: Any) -> PacketList:
    ...

@conf.commands.register
def bridge_and_sniff(if1: _GlobInterfaceType, if2: _GlobInterfaceType, xfrm12: Optional[Callable[[Packet], Union[Packet, bool]]] = ..., xfrm21: Optional[Callable[[Packet], Union[Packet, bool]]] = ..., prn: Optional[Callable[[Packet], Any]] = ..., L2socket: Optional[Type[SuperSocket]] = ..., *args: Any, **kargs: Any) -> PacketList:
    """Forward traffic between interfaces if1 and if2, sniff and return
    the exchanged packets.

    :param if1: the interfaces to use (interface names or opened sockets).
    :param if2:
    :param xfrm12: a function to call when forwarding a packet from if1 to
        if2. If it returns True, the packet is forwarded as it. If it
        returns False or None, the packet is discarded. If it returns a
        packet, this packet is forwarded instead of the original packet
        one.
    :param xfrm21: same as xfrm12 for packets forwarded from if2 to if1.

    The other arguments are the same than for the function sniff(),
    except for offline, opened_socket and iface that are ignored.
    See help(sniff) for more.
    """
    ...

@conf.commands.register
def tshark(*args: Any, **kargs: Any) -> None:
    """Sniff packets and print them calling pkt.summary().
    This tries to replicate what text-wireshark (tshark) would look like"""
    ...

