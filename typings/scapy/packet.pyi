"""
This type stub file was generated by pyright.
"""

import scapy.modules.six as six
from scapy.fields import AnyField, Field
from scapy.config import conf
from scapy.compat import Any, Dict, Iterator, List, NoReturn, Optional, Sequence, Tuple, Type, Union
from scapy.base_classes import BasePacket, Packet_metaclass, _CanvasDumpExtended
from scapy.interfaces import _GlobInterfaceType
from scapy.utils import EDecimal

"""
Packet class

Provides:
 - the default Packet classes
 - binding mechanisms
 - fuzz() method
 - exploration methods: explore() / ls()
"""
_T = ...
class Packet(six.with_metaclass(Packet_metaclass, BasePacket, _CanvasDumpExtended)):
    __slots__ = ...
    name = ...
    fields_desc: Sequence[AnyField] = ...
    deprecated_fields: Dict[str, Tuple[str, str]] = ...
    overload_fields: Dict[Type[Packet], Dict[str, Any]] = ...
    payload_guess: List[Tuple[Dict[str, Any], Type[Packet]]] = ...
    show_indent = ...
    show_summary = ...
    match_subclass = ...
    class_dont_cache: Dict[Type[Packet], bool] = ...
    class_packetfields: Dict[Type[Packet], Any] = ...
    class_default_fields: Dict[Type[Packet], Dict[str, Any]] = ...
    class_default_fields_ref: Dict[Type[Packet], List[str]] = ...
    class_fieldtype: Dict[Type[Packet], Dict[str, AnyField]] = ...
    @classmethod
    def from_hexcap(cls: Type[Packet]) -> Packet:
        ...
    
    @classmethod
    def upper_bonds(self) -> None:
        ...
    
    @classmethod
    def lower_bonds(self) -> None:
        ...
    
    def __init__(self, _pkt: bytes = ..., post_transform: Any = ..., _internal: int = ..., _underlayer: Optional[Packet] = ..., **fields: Any) -> None:
        ...
    
    _PickleType = Tuple[Union[EDecimal, float], Optional[Union[EDecimal, float, None]], Optional[int], Optional[_GlobInterfaceType], Optional[int]]
    def __reduce__(self) -> Tuple[Type[Packet], Tuple[bytes], Packet._PickleType]:
        """Used by pickling methods"""
        ...
    
    def __setstate__(self, state: Packet._PickleType) -> Packet:
        """Rebuild state using pickable methods"""
        ...
    
    def __deepcopy__(self, memo: Any) -> Packet:
        """Used by copy.deepcopy"""
        ...
    
    def init_fields(self) -> None:
        """
        Initialize each fields of the fields_desc dict
        """
        ...
    
    def do_init_fields(self, flist: Sequence[AnyField]) -> None:
        """
        Initialize each fields of the fields_desc dict
        """
        ...
    
    def do_init_cached_fields(self) -> None:
        """
        Initialize each fields of the fields_desc dict, or use the cached
        fields information
        """
        ...
    
    def prepare_cached_fields(self, flist: Sequence[AnyField]) -> None:
        """
        Prepare the cached fields of the fields_desc dict
        """
        ...
    
    def dissection_done(self, pkt: Packet) -> None:
        """DEV: will be called after a dissection is completed"""
        ...
    
    def post_dissection(self, pkt: Packet) -> None:
        """DEV: is called after the dissection of the whole packet"""
        ...
    
    def get_field(self, fld: str) -> AnyField:
        """DEV: returns the field instance from the name of the field"""
        ...
    
    def add_payload(self, payload: Union[Packet, bytes]) -> None:
        ...
    
    def remove_payload(self) -> None:
        ...
    
    def add_underlayer(self, underlayer: Packet) -> None:
        ...
    
    def remove_underlayer(self, other: Packet) -> None:
        ...
    
    def copy(self) -> Packet:
        """Returns a deep copy of the instance."""
        ...
    
    def getfieldval(self, attr: str) -> Any:
        ...
    
    def getfield_and_val(self, attr: str) -> Tuple[AnyField, Any]:
        ...
    
    def __getattr__(self, attr: str) -> Any:
        ...
    
    def setfieldval(self, attr: str, val: Any) -> None:
        ...
    
    def __setattr__(self, attr: str, val: Any) -> None:
        ...
    
    def delfieldval(self, attr: str) -> None:
        ...
    
    def __delattr__(self, attr: str) -> None:
        ...
    
    def __dir__(self) -> List[str]:
        """
        Add fields to tab completion list.
        """
        ...
    
    def __repr__(self) -> str:
        ...
    
    if six.PY2:
        def __str__(self) -> str:
            ...
        
    else:
        def __str__(self) -> str:
            ...
        
    def __bytes__(self) -> bytes:
        ...
    
    def __div__(self, other: Any) -> Packet:
        ...
    
    __truediv__ = ...
    def __rdiv__(self, other: Any) -> Packet:
        ...
    
    __rtruediv__ = ...
    def __mul__(self, other: Any) -> List[Packet]:
        ...
    
    def __rmul__(self, other: Any) -> List[Packet]:
        ...
    
    def __nonzero__(self) -> bool:
        ...
    
    __bool__ = ...
    def __len__(self) -> int:
        ...
    
    def copy_field_value(self, fieldname: str, value: Any) -> Any:
        ...
    
    def copy_fields_dict(self, fields: _T) -> _T:
        ...
    
    def clear_cache(self) -> None:
        """Clear the raw packet cache for the field and all its subfields"""
        ...
    
    def self_build(self) -> bytes:
        """
        Create the default layer regarding fields_desc dict

        :param field_pos_list:
        """
        ...
    
    def do_build_payload(self) -> bytes:
        """
        Create the default version of the payload layer

        :return: a string of payload layer
        """
        ...
    
    def do_build(self) -> bytes:
        """
        Create the default version of the layer

        :return: a string of the packet with the payload
        """
        ...
    
    def build_padding(self) -> bytes:
        ...
    
    def build(self) -> bytes:
        """
        Create the current layer

        :return: string of the packet with the payload
        """
        ...
    
    def post_build(self, pkt: bytes, pay: bytes) -> bytes:
        """
        DEV: called right after the current layer is build.

        :param str pkt: the current packet (build by self_buil function)
        :param str pay: the packet payload (build by do_build_payload function)
        :return: a string of the packet with the payload
        """
        ...
    
    def build_done(self, p: bytes) -> bytes:
        ...
    
    def do_build_ps(self) -> Tuple[bytes, List[Tuple[Packet, List[Tuple[Field[Any, Any], str, bytes]]]]]:
        ...
    
    def build_ps(self, internal: int = ...) -> Tuple[bytes, List[Tuple[Packet, List[Tuple[Any, Any, bytes]]]]]:
        ...
    
    def canvas_dump(self, layer_shift: int = ..., rebuild: int = ...) -> pyx.canvas.canvas:
        ...
    
    def extract_padding(self, s: bytes) -> Tuple[bytes, Optional[bytes]]:
        """
        DEV: to be overloaded to extract current layer's padding.

        :param str s: the current layer
        :return: a couple of strings (actual layer, padding)
        """
        ...
    
    def post_dissect(self, s: bytes) -> bytes:
        """DEV: is called right after the current layer has been dissected"""
        ...
    
    def pre_dissect(self, s: bytes) -> bytes:
        """DEV: is called right before the current layer is dissected"""
        ...
    
    def do_dissect(self, s: bytes) -> bytes:
        ...
    
    def do_dissect_payload(self, s: bytes) -> None:
        """
        Perform the dissection of the layer's payload

        :param str s: the raw layer
        """
        ...
    
    def dissect(self, s: bytes) -> None:
        ...
    
    def guess_payload_class(self, payload: bytes) -> Type[Packet]:
        """
        DEV: Guesses the next payload class from layer bonds.
        Can be overloaded to use a different mechanism.

        :param str payload: the layer's payload
        :return: the payload class
        """
        ...
    
    def default_payload_class(self, payload: bytes) -> Type[Packet]:
        """
        DEV: Returns the default payload class if nothing has been found by the
        guess_payload_class() method.

        :param str payload: the layer's payload
        :return: the default payload class define inside the configuration file
        """
        ...
    
    def hide_defaults(self) -> None:
        """Removes fields' values that are the same as default values."""
        ...
    
    def update_sent_time(self, time: Optional[float]) -> None:
        """Use by clone_with to share the sent_time value"""
        ...
    
    def clone_with(self, payload: Optional[Any] = ..., share_time: bool = ..., **kargs: Any) -> Any:
        ...
    
    def __iter__(self) -> Iterator[Packet]:
        """Iterates through all sub-packets generated by this Packet."""
        ...
    
    def __iterlen__(self) -> int:
        """Predict the total length of the iterator"""
        ...
    
    def iterpayloads(self) -> Iterator[Packet]:
        """Used to iter through the payloads of a Packet.
        Useful for DNS or 802.11 for instance.
        """
        ...
    
    def __gt__(self, other: Packet) -> int:
        """True if other is an answer from self (self ==> other)."""
        ...
    
    def __lt__(self, other: Packet) -> int:
        """True if self is an answer from other (other ==> self)."""
        ...
    
    def __eq__(self, other: Any) -> bool:
        ...
    
    def __ne__(self, other: Any) -> bool:
        ...
    
    __hash__ = ...
    def hashret(self) -> bytes:
        """DEV: returns a string that has the same value for a request
        and its answer."""
        ...
    
    def answers(self, other: Packet) -> int:
        """DEV: true if self is an answer from other"""
        ...
    
    def layers(self) -> List[Type[Packet]]:
        """returns a list of layer classes (including subclasses) in this packet"""
        ...
    
    def haslayer(self, cls: Union[Type[Packet], str], _subclass: Optional[bool] = ...) -> int:
        """
        true if self has a layer that is an instance of cls.
        Superseded by "cls in self" syntax.
        """
        ...
    
    def getlayer(self, cls: Union[int, Type[Packet], str], nb: int = ..., _track: Optional[List[int]] = ..., _subclass: Optional[bool] = ..., **flt: Any) -> Optional[Packet]:
        """Return the nb^th layer that is an instance of cls, matching flt
values.
        """
        ...
    
    def firstlayer(self) -> Packet:
        ...
    
    def __getitem__(self, cls: Union[Type[Packet], str]) -> Any:
        ...
    
    def __delitem__(self, cls: Type[Packet]) -> None:
        ...
    
    def __setitem__(self, cls: Type[Packet], val: Packet) -> None:
        ...
    
    def __contains__(self, cls: Union[Type[Packet], str]) -> int:
        """
        "cls in self" returns true if self has a layer which is an
        instance of cls.
        """
        ...
    
    def route(self) -> Tuple[Any, Optional[str], Optional[str]]:
        ...
    
    def fragment(self, *args: Any, **kargs: Any) -> List[Packet]:
        ...
    
    def display(self, *args: Any, **kargs: Any) -> None:
        """Deprecated. Use show() method."""
        ...
    
    def show(self, dump: bool = ..., indent: int = ..., lvl: str = ..., label_lvl: str = ...) -> Optional[Any]:
        """
        Prints or returns (when "dump" is true) a hierarchical view of the
        packet.

        :param dump: determine if it prints or returns the string value
        :param int indent: the size of indentation for each layer
        :param str lvl: additional information about the layer lvl
        :param str label_lvl: additional information about the layer fields
        :return: return a hierarchical view if dump, else print it
        """
        ...
    
    def show2(self, dump: bool = ..., indent: int = ..., lvl: str = ..., label_lvl: str = ...) -> Optional[Any]:
        """
        Prints or returns (when "dump" is true) a hierarchical view of an
        assembled version of the packet, so that automatic fields are
        calculated (checksums, etc.)

        :param dump: determine if it prints or returns the string value
        :param int indent: the size of indentation for each layer
        :param str lvl: additional information about the layer lvl
        :param str label_lvl: additional information about the layer fields
        :return: return a hierarchical view if dump, else print it
        """
        ...
    
    def sprintf(self, fmt: str, relax: int = ...) -> str:
        """
        sprintf(format, [relax=1]) -> str

        Where format is a string that can include directives. A directive
        begins and ends by % and has the following format:
        ``%[fmt[r],][cls[:nb].]field%``

        :param fmt: is a classic printf directive, "r" can be appended for raw
          substitution:
          (ex: IP.flags=0x18 instead of SA), nb is the number of the layer
          (ex: for IP/IP packets, IP:2.src is the src of the upper IP layer).
          Special case : "%.time%" is the creation time.
          Ex::

            p.sprintf(
              "%.time% %-15s,IP.src% -> %-15s,IP.dst% %IP.chksum% "
              "%03xr,IP.proto% %r,TCP.flags%"
            )

          Moreover, the format string can include conditional statements. A
          conditional statement looks like : {layer:string} where layer is a
          layer name, and string is the string to insert in place of the
          condition if it is true, i.e. if layer is present. If layer is
          preceded by a "!", the result is inverted. Conditions can be
          imbricated. A valid statement can be::

            p.sprintf("This is a{TCP: TCP}{UDP: UDP}{ICMP:n ICMP} packet")
            p.sprintf("{IP:%IP.dst% {ICMP:%ICMP.type%}{TCP:%TCP.dport%}}")

          A side effect is that, to obtain "{" and "}" characters, you must use
          "%(" and "%)".
        """
        ...
    
    def mysummary(self) -> str:
        """DEV: can be overloaded to return a string that summarizes the layer.
           Only one mysummary() is used in a whole packet summary: the one of the upper layer,  # noqa: E501
           except if a mysummary() also returns (as a couple) a list of layers whose  # noqa: E501
           mysummary() must be called if they are present."""
        ...
    
    def summary(self, intern: int = ...) -> str:
        """Prints a one line summary of a packet."""
        ...
    
    def lastlayer(self, layer: Optional[Packet] = ...) -> Packet:
        """Returns the uppest layer of the packet"""
        ...
    
    def decode_payload_as(self, cls: Type[Packet]) -> None:
        """Reassembles the payload and decode it using another packet class"""
        ...
    
    def command(self) -> str:
        """
        Returns a string representing the command you have to type to
        obtain the same packet
        """
        ...
    
    def convert_to(self, other_cls: Type[Packet], **kwargs: Any) -> Packet:
        """Converts this Packet to another type.

        This is not guaranteed to be a lossless process.

        By default, this only implements conversion to ``Raw``.

        :param other_cls: Reference to a Packet class to convert to.
        :type other_cls: Type[scapy.packet.Packet]
        :return: Converted form of the packet.
        :rtype: other_cls
        :raises TypeError: When conversion is not possible
        """
        ...
    
    @classmethod
    def convert_packet(cls, pkt: Packet, **kwargs: Any) -> Packet:
        """Converts another packet to be this type.

        This is not guaranteed to be a lossless process.

        :param pkt: The packet to convert.
        :type pkt: scapy.packet.Packet
        :return: Converted form of the packet.
        :rtype: cls
        :raises TypeError: When conversion is not possible
        """
        ...
    
    @classmethod
    def convert_packets(cls, pkts: List[Packet], **kwargs: Any) -> Iterator[Iterator[Packet]]:
        """Converts many packets to this type.

        This is implemented as a generator.

        See ``Packet.convert_packet``.
        """
        ...
    


class NoPayload(Packet):
    def __new__(cls: Type[Packet], *args: Any, **kargs: Any) -> Packet:
        ...
    
    def __init__(self, *args: Any, **kargs: Any) -> None:
        ...
    
    def dissection_done(self, pkt: Packet) -> None:
        ...
    
    def add_payload(self, payload: Union[Packet, bytes]) -> NoReturn:
        ...
    
    def remove_payload(self) -> None:
        ...
    
    def add_underlayer(self, underlayer: Any) -> None:
        ...
    
    def remove_underlayer(self, other: Packet) -> None:
        ...
    
    def copy(self) -> NoPayload:
        ...
    
    def clear_cache(self) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __bytes__(self) -> bytes:
        ...
    
    def __nonzero__(self) -> bool:
        ...
    
    __bool__ = ...
    def do_build(self) -> bytes:
        ...
    
    def build(self) -> bytes:
        ...
    
    def build_padding(self) -> bytes:
        ...
    
    def build_done(self, p: bytes) -> bytes:
        ...
    
    def build_ps(self, internal: int = ...) -> Tuple[bytes, List[Any]]:
        ...
    
    def getfieldval(self, attr: str) -> NoReturn:
        ...
    
    def getfield_and_val(self, attr: str) -> NoReturn:
        ...
    
    def setfieldval(self, attr: str, val: Any) -> NoReturn:
        ...
    
    def delfieldval(self, attr: str) -> NoReturn:
        ...
    
    def hide_defaults(self) -> None:
        ...
    
    def __iter__(self) -> Iterator[Packet]:
        ...
    
    def __eq__(self, other: Any) -> bool:
        ...
    
    def hashret(self) -> bytes:
        ...
    
    def answers(self, other: NoPayload) -> bool:
        ...
    
    def haslayer(self, cls: Union[Type[Packet], str], _subclass: Optional[bool] = ...) -> int:
        ...
    
    def getlayer(self, cls: Union[int, Type[Packet], str], nb: int = ..., _track: Optional[List[int]] = ..., _subclass: Optional[bool] = ..., **flt: Any) -> Optional[Packet]:
        ...
    
    def fragment(self, *args: Any, **kargs: Any) -> List[Packet]:
        ...
    
    def show(self, dump: bool = ..., indent: int = ..., lvl: str = ..., label_lvl: str = ...) -> None:
        ...
    
    def sprintf(self, fmt: str, relax: int = ...) -> str:
        ...
    
    def layers(self) -> List[Type[Packet]]:
        ...
    
    def lastlayer(self, layer: Optional[Packet] = ...) -> Packet:
        ...
    
    def command(self) -> str:
        ...
    
    def route(self) -> Tuple[None, None, None]:
        ...
    


class Raw(Packet):
    name = ...
    fields_desc = ...
    def __init__(self, _pkt: bytes = ..., *args: Any, **kwargs: Any) -> None:
        ...
    
    def answers(self, other: Packet) -> int:
        ...
    
    def mysummary(self) -> str:
        ...
    
    @classmethod
    def convert_packet(cls, pkt: Packet, **kwargs: Any) -> Raw:
        ...
    


class Padding(Raw):
    name = ...
    def self_build(self, field_pos_list: Optional[Any] = ...) -> bytes:
        ...
    
    def build_padding(self) -> bytes:
        ...
    


if conf.default_l2 is None:
    ...
def bind_bottom_up(lower: Type[Packet], upper: Type[Packet], __fval: Optional[Any] = ..., **fval: Any) -> None:
    r"""Bind 2 layers for dissection.
    The upper layer will be chosen for dissection on top of the lower layer, if
    ALL the passed arguments are validated. If multiple calls are made with
    the same layers, the last one will be used as default.

    ex:
        >>> bind_bottom_up(Ether, SNAP, type=0x1234)
        >>> Ether(b'\xff\xff\xff\xff\xff\xff\xd0P\x99V\xdd\xf9\x124\x00\x00\x00\x00\x00')  # noqa: E501
        <Ether  dst=ff:ff:ff:ff:ff:ff src=d0:50:99:56:dd:f9 type=0x1234 |<SNAP  OUI=0x0 code=0x0 |>>  # noqa: E501
    """
    ...

def bind_top_down(lower: Type[Packet], upper: Type[Packet], __fval: Optional[Any] = ..., **fval: Any) -> None:
    """Bind 2 layers for building.
    When the upper layer is added as a payload of the lower layer, all the
    arguments will be applied to them.

    ex:
        >>> bind_top_down(Ether, SNAP, type=0x1234)
        >>> Ether()/SNAP()
        <Ether  type=0x1234 |<SNAP  |>>
    """
    ...

@conf.commands.register
def bind_layers(lower: Type[Packet], upper: Type[Packet], __fval: Optional[Dict[str, int]] = ..., **fval: Any) -> None:
    """Bind 2 layers on some specific fields' values.

    It makes the packet being built and dissected when the arguments
    are present.

    This function calls both bind_bottom_up and bind_top_down, with
    all passed arguments.

    Please have a look at their docs:
     - help(bind_bottom_up)
     - help(bind_top_down)
     """
    ...

def split_bottom_up(lower: Type[Packet], upper: Type[Packet], __fval: Optional[Any] = ..., **fval: Any) -> None:
    """This call un-links an association that was made using bind_bottom_up.
    Have a look at help(bind_bottom_up)
    """
    ...

def split_top_down(lower: Type[Packet], upper: Type[Packet], __fval: Optional[Any] = ..., **fval: Any) -> None:
    """This call un-links an association that was made using bind_top_down.
    Have a look at help(bind_top_down)
    """
    ...

@conf.commands.register
def split_layers(lower: Type[Packet], upper: Type[Packet], __fval: Optional[Any] = ..., **fval: Any) -> None:
    """Split 2 layers previously bound.
    This call un-links calls bind_top_down and bind_bottom_up. It is the opposite of  # noqa: E501
    bind_layers.

    Please have a look at their docs:
     - help(split_bottom_up)
     - help(split_top_down)
    """
    ...

@conf.commands.register
def explore(layer: Optional[str] = ...) -> None:
    """Function used to discover the Scapy layers and protocols.
    It helps to see which packets exists in contrib or layer files.

    params:
     - layer: If specified, the function will explore the layer. If not,
              the GUI mode will be activated, to browse the available layers

    examples:
      >>> explore()  # Launches the GUI
      >>> explore("dns")  # Explore scapy.layers.dns
      >>> explore("http2")  # Explore scapy.contrib.http2
      >>> explore(scapy.layers.bluetooth4LE)

    Note: to search a packet by name, use ls("name") rather than explore.
    """
    ...

@conf.commands.register
def ls(obj: Optional[Union[str, Packet, Type[Packet]]] = ..., case_sensitive: bool = ..., verbose: bool = ...) -> None:
    """List  available layers, or infos on a given layer class or name.

    :param obj: Packet / packet name to use
    :param case_sensitive: if obj is a string, is it case sensitive?
    :param verbose:
    """
    ...

@conf.commands.register
def rfc(cls: Type[Packet], ret: bool = ..., legend: bool = ...) -> Optional[str]:
    """
    Generate an RFC-like representation of a packet def.

    :param cls: the Packet class
    :param ret: return the result instead of printing (def. False)
    :param legend: show text under the diagram (default True)

    Ex::

        >>> rfc(Ether)

    """
    ...

@conf.commands.register
def fuzz(p: Packet, _inplace: int = ...) -> Packet:
    """
    Transform a layer into a fuzzy layer by replacing some default values
    by random objects.

    :param p: the Packet instance to fuzz
    :return: the fuzzed packet.
    """
    ...

