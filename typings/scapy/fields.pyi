"""
This type stub file was generated by pyright.
"""

import scapy.modules.six as six
from uuid import UUID
from scapy.dadict import DADict
from scapy.volatile import RandBin, RandEnumKeys, RandFloat, RandIP, RandIP6, RandMAC, RandNum, RandTermString, RandUUID, VolatileValue
from scapy.error import Scapy_Exception
from scapy.compat import Any, AnyStr, Callable, Dict, Generic, List, Optional, Set, TYPE_CHECKING, Tuple, Type, Union
from scapy.utils import EDecimal
from scapy.utils6 import Net6
from scapy.base_classes import BasePacket, Field_metaclass, Net
from scapy.packet import Packet

"""
Fields: basic data structures that make up parts of packets.
"""
if TYPE_CHECKING:
    ...
class RawVal:
    r"""
    A raw value that will not be processed by the field and inserted
    as-is in the packet string.

    Example::

        >>> a = IP(len=RawVal("####"))
        >>> bytes(a)
        b'F\x00####\x00\x01\x00\x005\xb5\x00\x00\x7f\x00\x00\x01\x7f\x00\x00\x01\x00\x00'

    """
    def __init__(self, val: bytes = ...) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __bytes__(self) -> bytes:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __repr__(self) -> str:
        ...
    


class ObservableDict(Dict[int, str]):
    """
    Helper class to specify a protocol extendable for runtime modifications
    """
    def __init__(self, *args: Dict[int, str], **kw: Any) -> None:
        ...
    
    def observe(self, observer: _EnumField[Any]) -> None:
        ...
    
    def __setitem__(self, key: int, value: str) -> None:
        ...
    
    def __delitem__(self, key: int) -> None:
        ...
    
    def update(self, anotherDict): # -> None:
        ...
    


I = ...
M = ...
@six.add_metaclass(Field_metaclass)
class Field(Generic[I, M]):
    """
    For more information on how this works, please refer to the
    'Adding new protocols' chapter in the online documentation:

    https://scapy.readthedocs.io/en/stable/build_dissect.html
    """
    __slots__ = ...
    islist = ...
    ismutable = ...
    holds_packets = ...
    def __init__(self, name: str, default: Any, fmt: str = ...) -> None:
        ...
    
    def register_owner(self, cls: Type[Packet]) -> None:
        ...
    
    def i2len(self, pkt: Packet, x: Any) -> int:
        """Convert internal value to a length usable by a FieldLenField"""
        ...
    
    def i2count(self, pkt: Optional[Packet], x: I) -> int:
        """Convert internal value to a number of elements usable by a FieldLenField.
        Always 1 except for list fields"""
        ...
    
    def h2i(self, pkt: Optional[Packet], x: Any) -> I:
        """Convert human value to internal value"""
        ...
    
    def i2h(self, pkt: Optional[Packet], x: I) -> Any:
        """Convert internal value to human value"""
        ...
    
    def m2i(self, pkt: Optional[Packet], x: M) -> I:
        """Convert machine value to internal value"""
        ...
    
    def i2m(self, pkt: Optional[Packet], x: Optional[I]) -> M:
        """Convert internal value to machine value"""
        ...
    
    def any2i(self, pkt: Optional[Packet], x: Any) -> Optional[I]:
        """Try to understand the most input values possible and make an internal value from them"""
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: I) -> str:
        """Convert internal value to a nice representation"""
        ...
    
    def addfield(self, pkt: Packet, s: bytes, val: Optional[I]) -> bytes:
        """Add an internal value to a string

        Copy the network representation of field `val` (belonging to layer
        `pkt`) to the raw string packet `s`, and return the new string packet.
        """
        ...
    
    def getfield(self, pkt: Packet, s: bytes) -> Tuple[bytes, I]:
        """Extract an internal value from a string

        Extract from the raw packet `s` the field value belonging to layer
        `pkt`.

        Returns a two-element list,
        first the raw packet string after having removed the extracted field,
        second the extracted field itself in internal representation.
        """
        ...
    
    def do_copy(self, x: I) -> I:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def copy(self) -> Field[I, M]:
        ...
    
    def randval(self) -> VolatileValue:
        """Return a volatile object whose value is both random and suitable for this field"""
        ...
    


class _FieldContainer:
    """
    A field that acts as a container for another field
    """
    def __getattr__(self, attr: str) -> Any:
        ...
    


AnyField = Union[Field[Any, Any], _FieldContainer]
class Emph(_FieldContainer):
    """Empathize sub-layer for display"""
    __slots__ = ...
    def __init__(self, fld: Any) -> None:
        ...
    
    def __eq__(self, other: Any) -> bool:
        ...
    
    def __ne__(self, other: Any) -> bool:
        ...
    
    __hash__ = ...


class ActionField(_FieldContainer):
    __slots__ = ...
    def __init__(self, fld: Field[Any, Any], action_method: str, **kargs: Any) -> None:
        ...
    
    def any2i(self, pkt: Optional[Packet], val: int) -> Any:
        ...
    


class ConditionalField(_FieldContainer):
    __slots__ = ...
    def __init__(self, fld: Field[Any, Any], cond: Callable[[Packet], bool]) -> None:
        ...
    
    def any2i(self, pkt: Optional[Packet], x: Any) -> Any:
        ...
    
    def i2h(self, pkt: Optional[Packet], val: Any) -> Any:
        ...
    
    def getfield(self, pkt: Packet, s: bytes) -> Tuple[bytes, Any]:
        ...
    
    def addfield(self, pkt: Packet, s: bytes, val: Any) -> bytes:
        ...
    
    def __getattr__(self, attr: str) -> Any:
        ...
    


class MultipleTypeField(_FieldContainer):
    """MultipleTypeField are used for fields that can be implemented by
various Field subclasses, depending on conditions on the packet.

It is initialized with `flds` and `dflt`.

`dflt` is the default field type, to be used when none of the
conditions matched the current packet.

`flds` is a list of tuples (`fld`, `cond`), where `fld` if a field
type, and `cond` a "condition" to determine if `fld` is the field type
that should be used.

`cond` is either:

  - a callable `cond_pkt` that accepts one argument (the packet) and
    returns True if `fld` should be used, False otherwise.

  - a tuple (`cond_pkt`, `cond_pkt_val`), where `cond_pkt` is the same
    as in the previous case and `cond_pkt_val` is a callable that
    accepts two arguments (the packet, and the value to be set) and
    returns True if `fld` should be used, False otherwise.

See scapy.layers.l2.ARP (type "help(ARP)" in Scapy) for an example of
use.

    """
    __slots__ = ...
    def __init__(self, flds: List[Tuple[Field[Any, Any], Any]], dflt: Field[Any, Any]) -> None:
        ...
    
    def getfield(self, pkt: Packet, s: bytes) -> Tuple[bytes, Any]:
        ...
    
    def addfield(self, pkt: Packet, s: bytes, val: Any) -> bytes:
        ...
    
    def any2i(self, pkt: Optional[Packet], val: Any) -> Any:
        ...
    
    def h2i(self, pkt: Optional[Packet], val: Any) -> Any:
        ...
    
    def i2h(self, pkt: Packet, val: Any) -> Any:
        ...
    
    def i2m(self, pkt: Optional[Packet], val: Optional[Any]) -> Any:
        ...
    
    def i2len(self, pkt: Packet, val: Any) -> int:
        ...
    
    def i2repr(self, pkt: Optional[Packet], val: Any) -> str:
        ...
    
    def register_owner(self, cls: Type[Packet]) -> None:
        ...
    
    @property
    def fld(self) -> Field[Any, Any]:
        ...
    


class PadField(_FieldContainer):
    """Add bytes after the proxified field so that it ends at the specified
       alignment from its beginning"""
    __slots__ = ...
    def __init__(self, fld: Field[Any, Any], align: int, padwith: Optional[bytes] = ...) -> None:
        ...
    
    def padlen(self, flen: int) -> int:
        ...
    
    def getfield(self, pkt: Packet, s: bytes) -> Tuple[bytes, Any]:
        ...
    
    def addfield(self, pkt: Packet, s: bytes, val: Any) -> bytes:
        ...
    


class ReversePadField(PadField):
    """Add bytes BEFORE the proxified field so that it starts at the specified
       alignment from its beginning"""
    def getfield(self, pkt: Packet, s: bytes) -> Tuple[bytes, Any]:
        ...
    
    def addfield(self, pkt: Packet, s: bytes, val: Any) -> bytes:
        ...
    


class FCSField(Field[int, int]):
    """Special Field that gets its value from the end of the *packet*
    (Note: not layer, but packet).

    Mostly used for FCS
    """
    def getfield(self, pkt: Packet, s: bytes) -> Tuple[bytes, int]:
        ...
    
    def addfield(self, pkt: Packet, s: bytes, val: Optional[int]) -> bytes:
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: int) -> str:
        ...
    


class DestField(Field[str, bytes]):
    __slots__ = ...
    bindings: Dict[Type[Packet], Tuple[str, Any]] = ...
    def __init__(self, name: str, default: str) -> None:
        ...
    
    def dst_from_pkt(self, pkt: Packet) -> str:
        ...
    
    @classmethod
    def bind_addr(cls, layer: Type[Packet], addr: str, **condition: Any) -> None:
        ...
    


class MACField(Field[Optional[str], bytes]):
    def __init__(self, name: str, default: Optional[Any]) -> None:
        ...
    
    def i2m(self, pkt: Optional[Packet], x: Optional[str]) -> bytes:
        ...
    
    def m2i(self, pkt: Optional[Packet], x: bytes) -> str:
        ...
    
    def any2i(self, pkt: Optional[Packet], x: Any) -> str:
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: Optional[str]) -> str:
        ...
    
    def randval(self) -> RandMAC:
        ...
    


class IPField(Field[Union[str, Net], bytes]):
    def __init__(self, name: str, default: Optional[str]) -> None:
        ...
    
    def h2i(self, pkt: Optional[Packet], x: Union[AnyStr, List[AnyStr]]) -> Any:
        ...
    
    def i2h(self, pkt: Optional[Packet], x: Optional[Union[str, Net]]) -> str:
        ...
    
    def resolve(self, x: str) -> str:
        ...
    
    def i2m(self, pkt: Optional[Packet], x: Optional[Union[str, Net]]) -> bytes:
        ...
    
    def m2i(self, pkt: Optional[Packet], x: bytes) -> str:
        ...
    
    def any2i(self, pkt: Optional[Packet], x: Any) -> Any:
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: Union[str, Net]) -> str:
        ...
    
    def randval(self) -> RandIP:
        ...
    


class SourceIPField(IPField):
    __slots__ = ...
    def __init__(self, name: str, dstname: Optional[str]) -> None:
        ...
    
    def i2m(self, pkt: Optional[Packet], x: Optional[Union[str, Net]]) -> bytes:
        ...
    
    def i2h(self, pkt: Optional[Packet], x: Optional[Union[str, Net]]) -> str:
        ...
    


class IP6Field(Field[Optional[Union[str, Net6]], bytes]):
    def __init__(self, name: str, default: Optional[str]) -> None:
        ...
    
    def h2i(self, pkt: Optional[Packet], x: Optional[str]) -> str:
        ...
    
    def i2h(self, pkt: Optional[Packet], x: Optional[Union[str, Net6]]) -> str:
        ...
    
    def i2m(self, pkt: Optional[Packet], x: Optional[Union[str, Net6]]) -> bytes:
        ...
    
    def m2i(self, pkt: Optional[Packet], x: bytes) -> str:
        ...
    
    def any2i(self, pkt: Optional[Packet], x: Optional[str]) -> str:
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: Optional[Union[str, Net6]]) -> str:
        ...
    
    def randval(self) -> RandIP6:
        ...
    


class SourceIP6Field(IP6Field):
    __slots__ = ...
    def __init__(self, name: str, dstname: str) -> None:
        ...
    
    def i2m(self, pkt: Optional[Packet], x: Optional[Union[str, Net6]]) -> bytes:
        ...
    
    def i2h(self, pkt: Optional[Packet], x: Optional[Union[str, Net6]]) -> str:
        ...
    


class DestIP6Field(IP6Field, DestField):
    bindings: Dict[Type[Packet], Tuple[str, Any]] = ...
    def __init__(self, name: str, default: str) -> None:
        ...
    
    def i2m(self, pkt: Optional[Packet], x: Optional[Union[str, Net6]]) -> bytes:
        ...
    
    def i2h(self, pkt: Optional[Packet], x: Optional[Union[str, Net6]]) -> str:
        ...
    


class ByteField(Field[int, int]):
    def __init__(self, name: str, default: Optional[int]) -> None:
        ...
    


class XByteField(ByteField):
    def i2repr(self, pkt: Optional[Packet], x: int) -> str:
        ...
    


class OByteField(ByteField):
    def i2repr(self, pkt: Optional[Packet], x: int) -> str:
        ...
    


class ThreeBytesField(Field[int, int]):
    def __init__(self, name: str, default: int) -> None:
        ...
    
    def addfield(self, pkt: Packet, s: bytes, val: Optional[int]) -> bytes:
        ...
    
    def getfield(self, pkt: Packet, s: bytes) -> Tuple[bytes, int]:
        ...
    


class X3BytesField(ThreeBytesField, XByteField):
    def i2repr(self, pkt: Optional[Packet], x: int) -> str:
        ...
    


class LEThreeBytesField(ByteField):
    def __init__(self, name: str, default: Optional[int]) -> None:
        ...
    
    def addfield(self, pkt: Packet, s: bytes, val: Optional[int]) -> bytes:
        ...
    
    def getfield(self, pkt: Optional[Packet], s: bytes) -> Tuple[bytes, int]:
        ...
    


class LEX3BytesField(LEThreeBytesField, XByteField):
    def i2repr(self, pkt: Optional[Packet], x: int) -> str:
        ...
    


class NBytesField(Field[int, List[int]]):
    def __init__(self, name: str, default: Optional[int], sz: int) -> None:
        ...
    
    def i2m(self, pkt: Optional[Packet], x: Optional[int]) -> List[int]:
        ...
    
    def m2i(self, pkt: Optional[Packet], x: Union[List[int], int]) -> int:
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: int) -> str:
        ...
    
    def addfield(self, pkt: Optional[Packet], s: bytes, val: Optional[int]) -> bytes:
        ...
    
    def getfield(self, pkt: Optional[Packet], s: bytes) -> Tuple[bytes, int]:
        ...
    


class XNBytesField(NBytesField):
    def i2repr(self, pkt: Optional[Packet], x: int) -> str:
        ...
    


class SignedByteField(Field[int, int]):
    def __init__(self, name: str, default: Optional[int]) -> None:
        ...
    


class FieldValueRangeException(Scapy_Exception):
    ...


class FieldAttributeException(Scapy_Exception):
    ...


class YesNoByteField(ByteField):
    """
    A byte based flag field that shows representation of its number
    based on a given association

    In its default configuration the following representation is generated:
        x == 0 : 'no'
        x != 0 : 'yes'

    In more sophisticated use-cases (e.g. yes/no/invalid) one can use the
    config attribute to configure.
    Key-value, key-range and key-value-set associations that will be used to
    generate the values representation.

    - A range is given by a tuple (<first-val>, <last-value>) including the
      last value.
    - A single-value tuple is treated as scalar.
    - A list defines a set of (probably non consecutive) values that should be
      associated to a given key.

    All values not associated with a key will be shown as number of type
    unsigned byte.

    **For instance**::

        config = {
            'no' : 0,
            'foo' : (1,22),
            'yes' : 23,
            'bar' : [24,25, 42, 48, 87, 253]
        }

    Generates the following representations::

        x == 0 : 'no'
        x == 15: 'foo'
        x == 23: 'yes'
        x == 42: 'bar'
        x == 43: 43

    Another example, using the config attribute one could also revert
    the stock-yes-no-behavior::

        config = {
                'yes' : 0,
                'no' : (1,255)
        }

    Will generate the following value representation::

        x == 0 : 'yes'
        x != 0 : 'no'

    """
    __slots__ = ...
    def __init__(self, name: str, default: int, config: Optional[Dict[str, Any]] = ...) -> None:
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: int) -> str:
        ...
    


class ShortField(Field[int, int]):
    def __init__(self, name: str, default: Optional[int]) -> None:
        ...
    


class SignedShortField(Field[int, int]):
    def __init__(self, name: str, default: Optional[int]) -> None:
        ...
    


class LEShortField(Field[int, int]):
    def __init__(self, name: str, default: Optional[int]) -> None:
        ...
    


class LESignedShortField(Field[int, int]):
    def __init__(self, name: str, default: Optional[int]) -> None:
        ...
    


class XShortField(ShortField):
    def i2repr(self, pkt: Optional[Packet], x: int) -> str:
        ...
    


class IntField(Field[int, int]):
    def __init__(self, name: str, default: Optional[int]) -> None:
        ...
    


class SignedIntField(Field[int, int]):
    def __init__(self, name: str, default: int) -> None:
        ...
    


class LEIntField(Field[int, int]):
    def __init__(self, name: str, default: Optional[int]) -> None:
        ...
    


class LESignedIntField(Field[int, int]):
    def __init__(self, name: str, default: int) -> None:
        ...
    


class XIntField(IntField):
    def i2repr(self, pkt: Optional[Packet], x: int) -> str:
        ...
    


class XLEIntField(LEIntField, XIntField):
    def i2repr(self, pkt: Optional[Packet], x: int) -> str:
        ...
    


class XLEShortField(LEShortField, XShortField):
    def i2repr(self, pkt: Optional[Packet], x: int) -> str:
        ...
    


class LongField(Field[int, int]):
    def __init__(self, name: str, default: int) -> None:
        ...
    


class SignedLongField(Field[int, int]):
    def __init__(self, name: str, default: Optional[int]) -> None:
        ...
    


class LELongField(LongField):
    def __init__(self, name: str, default: Optional[int]) -> None:
        ...
    


class LESignedLongField(Field[int, int]):
    def __init__(self, name: str, default: Optional[Any]) -> None:
        ...
    


class XLongField(LongField):
    def i2repr(self, pkt: Optional[Packet], x: int) -> str:
        ...
    


class XLELongField(LELongField, XLongField):
    def i2repr(self, pkt: Optional[Packet], x: int) -> str:
        ...
    


class IEEEFloatField(Field[int, int]):
    def __init__(self, name: str, default: Optional[int]) -> None:
        ...
    


class IEEEDoubleField(Field[int, int]):
    def __init__(self, name: str, default: Optional[int]) -> None:
        ...
    


class _StrField(Field[I, bytes]):
    __slots__ = ...
    def __init__(self, name: str, default: Optional[I], fmt: str = ..., remain: int = ...) -> None:
        ...
    
    def i2len(self, pkt: Optional[Packet], x: Any) -> int:
        ...
    
    def any2i(self, pkt: Optional[Packet], x: Any) -> I:
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: I) -> str:
        ...
    
    def i2m(self, pkt: Optional[Packet], x: Optional[I]) -> bytes:
        ...
    
    def addfield(self, pkt: Packet, s: bytes, val: Optional[I]) -> bytes:
        ...
    
    def getfield(self, pkt: Packet, s: bytes) -> Tuple[bytes, I]:
        ...
    
    def randval(self) -> RandBin:
        ...
    


class StrField(_StrField[bytes]):
    ...


class StrFieldUtf16(StrField):
    def h2i(self, pkt: Optional[Packet], x: Optional[str]) -> bytes:
        ...
    
    def any2i(self, pkt: Optional[Packet], x: Optional[str]) -> bytes:
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: bytes) -> str:
        ...
    
    def i2h(self, pkt: Optional[Packet], x: bytes) -> str:
        ...
    


K = ...
class _PacketField(_StrField[K]):
    __slots__ = ...
    holds_packets = ...
    def __init__(self, name: str, default: Optional[K], pkt_cls: Union[Callable[[bytes], Packet], Type[Packet]]) -> None:
        ...
    
    def i2m(self, pkt: Optional[Packet], i: Any) -> bytes:
        ...
    
    def m2i(self, pkt: Optional[Packet], m: bytes) -> Packet:
        ...
    
    def getfield(self, pkt: Packet, s: bytes) -> Tuple[bytes, K]:
        ...
    
    def randval(self) -> K:
        ...
    


class PacketField(_PacketField[BasePacket]):
    ...


class PacketLenField(PacketField):
    __slots__ = ...
    def __init__(self, name: str, default: Packet, cls: Union[Callable[[bytes], Packet], Type[Packet]], length_from: Optional[Callable[[Packet], int]] = ...) -> None:
        ...
    
    def getfield(self, pkt: Packet, s: bytes) -> Tuple[bytes, Packet]:
        ...
    


class PacketListField(_PacketField[List[BasePacket]]):
    """PacketListField represents a series of Packet instances that might
    occur right in the middle of another Packet field list.
    This field type may also be used to indicate that a series of Packet
    instances have a sibling semantic instead of a parent/child relationship
    (i.e. a stack of layers).
    """
    __slots__ = ...
    islist = ...
    def __init__(self, name: str, default: Optional[List[BasePacket]], pkt_cls: Optional[Union[Callable[[bytes], Packet], Type[Packet]]] = ..., count_from: Optional[Callable[[Packet], int]] = ..., length_from: Optional[Callable[[Packet], int]] = ..., next_cls_cb: Optional[Callable[[Packet, List[BasePacket], Optional[Packet], bytes], Type[Packet]]] = ...) -> None:
        """
        The number of Packet instances that are dissected by this field can
        be parametrized using one of three different mechanisms/parameters:

            * count_from: a callback that returns the number of Packet
              instances to dissect. The callback prototype is::

                count_from(pkt:Packet) -> int

            * length_from: a callback that returns the number of bytes that
              must be dissected by this field. The callback prototype is::

                length_from(pkt:Packet) -> int

            * next_cls_cb: a callback that enables a Scapy developer to
              dynamically discover if another Packet instance should be
              dissected or not. See below for this callback prototype.

        The bytes that are not consumed during the dissection of this field
        are passed to the next field of the current packet.

        For the serialization of such a field, the list of Packets that are
        contained in a PacketListField can be heterogeneous and is
        unrestricted.

        The type of the Packet instances that are dissected with this field is
        specified or discovered using one of the following mechanism:

            * the pkt_cls parameter may contain a callable that returns an
              instance of the dissected Packet. This may either be a
              reference of a Packet subclass (e.g. DNSRROPT in layers/dns.py)
              to generate an homogeneous PacketListField or a function
              deciding the type of the Packet instance
              (e.g. _CDPGuessAddrRecord in contrib/cdp.py)

            * the pkt_cls parameter may contain a class object with a defined
              ``dispatch_hook`` classmethod. That method must return a Packet
              instance. The ``dispatch_hook`` callmethod must implement the
                following prototype::

                dispatch_hook(cls,
                              _pkt:Optional[Packet],
                              *args, **kargs
                ) -> Type[Packet]

                The _pkt parameter may contain a reference to the packet
                instance containing the PacketListField that is being
                dissected.

            * the ``next_cls_cb`` parameter may contain a callable whose
              prototype is::

                cbk(pkt:Packet,
                    lst:List[Packet],
                    cur:Optional[Packet],
                    remain:str
                ) -> Optional[Type[Packet]]

              The pkt argument contains a reference to the Packet instance
              containing the PacketListField that is being dissected.
              The lst argument is the list of all Packet instances that were
              previously parsed during the current ``PacketListField``
              dissection, saved for the very last Packet instance.
              The cur argument contains a reference to that very last parsed
              ``Packet`` instance. The remain argument contains the bytes
              that may still be consumed by the current PacketListField
              dissection operation.

              This callback returns either the type of the next Packet to
              dissect or None to indicate that no more Packet are to be
              dissected.

              These four arguments allows a variety of dynamic discovery of
              the number of Packet to dissect and of the type of each one of
              these Packets, including: type determination based on current
              Packet instances or its underlayers, continuation based on the
              previously parsed Packet instances within that PacketListField,
              continuation based on a look-ahead on the bytes to be
              dissected...

        The pkt_cls and next_cls_cb parameters are semantically exclusive,
        although one could specify both. If both are specified, pkt_cls is
        silently ignored. The same is true for count_from and next_cls_cb.

        length_from and next_cls_cb are compatible and the dissection will
        end, whichever of the two stop conditions comes first.

        :param name: the name of the field
        :param default: the default value of this field; generally an empty
            Python list
        :param pkt_cls: either a callable returning a Packet instance or a
            class object defining a ``dispatch_hook`` class method
        :param count_from: a callback returning the number of Packet
            instances to dissect.
        :param length_from: a callback returning the number of bytes to dissect
        :param next_cls_cb: a callback returning either None or the type of
            the next Packet to dissect.
        """
        ...
    
    def any2i(self, pkt: Optional[Packet], x: Any) -> List[BasePacket]:
        ...
    
    def i2count(self, pkt: Optional[Packet], val: List[BasePacket]) -> int:
        ...
    
    def i2len(self, pkt: Optional[Packet], val: List[Packet]) -> int:
        ...
    
    def getfield(self, pkt: Packet, s: bytes) -> Tuple[bytes, List[BasePacket]]:
        ...
    
    def addfield(self, pkt: Packet, s: bytes, val: Any) -> bytes:
        ...
    


class StrFixedLenField(StrField):
    __slots__ = ...
    def __init__(self, name: str, default: Optional[bytes], length: Optional[int] = ..., length_from: Optional[Callable[[Packet], int]] = ...) -> None:
        ...
    
    def i2repr(self, pkt: Optional[Packet], v: bytes) -> str:
        ...
    
    def getfield(self, pkt: Packet, s: bytes) -> Tuple[bytes, bytes]:
        ...
    
    def addfield(self, pkt: Packet, s: bytes, val: Optional[bytes]) -> bytes:
        ...
    
    def randval(self) -> RandBin:
        ...
    


class StrFixedLenEnumField(StrFixedLenField):
    __slots__ = ...
    def __init__(self, name: str, default: bytes, length: Optional[int] = ..., enum: Optional[Dict[str, str]] = ..., length_from: Optional[Callable[[Optional[Packet]], int]] = ...) -> None:
        ...
    
    def i2repr(self, pkt: Optional[Packet], w: bytes) -> str:
        ...
    


class NetBIOSNameField(StrFixedLenField):
    def __init__(self, name: str, default: bytes, length: int = ...) -> None:
        ...
    
    def i2m(self, pkt: Optional[Packet], y: Optional[bytes]) -> bytes:
        ...
    
    def m2i(self, pkt: Optional[Packet], x: bytes) -> bytes:
        ...
    


class StrLenField(StrField):
    __slots__ = ...
    def __init__(self, name: str, default: bytes, length_from: Optional[Callable[[Packet], int]] = ..., max_length: Optional[Any] = ...) -> None:
        ...
    
    def getfield(self, pkt: Any, s: bytes) -> Tuple[bytes, bytes]:
        ...
    
    def randval(self) -> RandBin:
        ...
    


class XStrField(StrField):
    """
    StrField which value is printed as hexadecimal.
    """
    def i2repr(self, pkt: Optional[Packet], x: bytes) -> str:
        ...
    


class _XStrLenField:
    def i2repr(self, pkt: Optional[Packet], x: bytes) -> str:
        ...
    


class XStrLenField(_XStrLenField, StrLenField):
    """
    StrLenField which value is printed as hexadecimal.
    """
    ...


class XStrFixedLenField(_XStrLenField, StrFixedLenField):
    """
    StrFixedLenField which value is printed as hexadecimal.
    """
    ...


class XLEStrLenField(XStrLenField):
    def i2m(self, pkt: Optional[Packet], x: Optional[bytes]) -> bytes:
        ...
    
    def m2i(self, pkt: Optional[Packet], x: bytes) -> bytes:
        ...
    


class StrLenFieldUtf16(StrLenField):
    def h2i(self, pkt: Optional[Packet], x: Optional[str]) -> bytes:
        ...
    
    def any2i(self, pkt: Optional[Packet], x: Any) -> bytes:
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: bytes) -> str:
        ...
    
    def i2h(self, pkt: Optional[Packet], x: bytes) -> str:
        ...
    


class BoundStrLenField(StrLenField):
    __slots__ = ...
    def __init__(self, name: str, default: bytes, minlen: int = ..., maxlen: int = ..., length_from: Optional[Callable[[Packet], int]] = ...) -> None:
        ...
    
    def randval(self) -> RandBin:
        ...
    


class FieldListField(Field[List[Any], List[Any]]):
    __slots__ = ...
    islist = ...
    def __init__(self, name: str, default: Optional[List[AnyField]], field: AnyField, length_from: Optional[Callable[[Packet], int]] = ..., count_from: Optional[Callable[[Packet], int]] = ...) -> None:
        ...
    
    def i2count(self, pkt: Optional[Packet], val: List[Any]) -> int:
        ...
    
    def i2len(self, pkt: Packet, val: List[Any]) -> int:
        ...
    
    def any2i(self, pkt: Optional[Packet], x: List[Any]) -> List[Any]:
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: List[Any]) -> str:
        ...
    
    def addfield(self, pkt: Packet, s: bytes, val: Optional[List[Any]]) -> bytes:
        ...
    
    def getfield(self, pkt: Packet, s: bytes) -> Any:
        ...
    


class FieldLenField(Field[int, int]):
    __slots__ = ...
    def __init__(self, name: str, default: Optional[Any], length_of: Optional[str] = ..., fmt: str = ..., count_of: Optional[str] = ..., adjust: Callable[[Packet, int], int] = ...) -> None:
        ...
    
    def i2m(self, pkt: Optional[Packet], x: Optional[int]) -> int:
        ...
    


class StrNullField(StrField):
    def addfield(self, pkt: Packet, s: bytes, val: Optional[bytes]) -> bytes:
        ...
    
    def getfield(self, pkt: Packet, s: bytes) -> Tuple[bytes, bytes]:
        ...
    
    def randval(self) -> RandTermString:
        ...
    


class StrStopField(StrField):
    __slots__ = ...
    def __init__(self, name: str, default: str, stop: bytes, additional: int = ...) -> None:
        ...
    
    def getfield(self, pkt: Optional[Packet], s: bytes) -> Tuple[bytes, bytes]:
        ...
    
    def randval(self) -> RandTermString:
        ...
    


class LenField(Field[int, int]):
    """
    If None, will be filled with the size of the payload
    """
    __slots__ = ...
    def __init__(self, name: str, default: Optional[Any], fmt: str = ..., adjust: Callable[[int], int] = ...) -> None:
        ...
    
    def i2m(self, pkt: Optional[Packet], x: Optional[int]) -> int:
        ...
    


class BCDFloatField(Field[float, int]):
    def i2m(self, pkt: Optional[Packet], x: Optional[float]) -> int:
        ...
    
    def m2i(self, pkt: Optional[Packet], x: int) -> float:
        ...
    


class _BitField(Field[I, int]):
    """
    Field to handle bits.

    :param name: name of the field
    :param default: default value
    :param size: size (in bits). If negative, Low endian
    :param tot_size: size of the total group of bits (in bytes) the bitfield
                     is in. If negative, Low endian.
    :param end_tot_size: same but for the BitField ending a group.

    Example - normal usage::

         0                   1                   2                   3
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             A             |               B               | C |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                 Fig. TestPacket

        class TestPacket(Packet):
            fields_desc = [
                BitField("a", 0, 14),
                BitField("b", 0, 16),
                BitField("c", 0, 2),
            ]

    Example - Low endian stored as 16 bits on the network::

        x x x x x x x x x x x x x x x x
        a [b] [   c   ] [      a      ]

        Will first get reversed during dissecion:

        x x x x x x x x x x x x x x x x
        [      a        ] [b] [   c   ]

        class TestPacket(Packet):
            fields_desc = [
                BitField("a", 0, 9, tot_size=-2),
                BitField("b", 0, 2),
                BitField("c", 0, 5, end_tot_size=-2)
            ]

    """
    __slots__ = ...
    def __init__(self, name: str, default: I, size: int, tot_size: int = ..., end_tot_size: int = ...) -> None:
        ...
    
    def addfield(self, pkt: Packet, s: Union[Tuple[bytes, int, int], bytes], ival: I) -> Union[Tuple[bytes, int, int], bytes]:
        ...
    
    def getfield(self, pkt: Packet, s: Union[Tuple[bytes, int], bytes]) -> Union[Tuple[Tuple[bytes, int], I], Tuple[bytes, I]]:
        ...
    
    def randval(self) -> RandNum:
        ...
    
    def i2len(self, pkt: Optional[Packet], x: Optional[float]) -> float:
        ...
    


class BitField(_BitField[int]):
    __doc__ = ...


class BitFixedLenField(BitField):
    __slots__ = ...
    def __init__(self, name: str, default: int, length_from: Callable[[Packet], int]) -> None:
        ...
    
    def getfield(self, pkt: Packet, s: Union[Tuple[bytes, int], bytes]) -> Union[Tuple[Tuple[bytes, int], int], Tuple[bytes, int]]:
        ...
    
    def addfield(self, pkt: Packet, s: Union[Tuple[bytes, int, int], bytes], val: int) -> Union[Tuple[bytes, int, int], bytes]:
        ...
    


class BitFieldLenField(BitField):
    __slots__ = ...
    def __init__(self, name: str, default: int, size: int, length_of: Optional[Union[Callable[[Optional[Packet]], int], str]] = ..., count_of: Optional[str] = ..., adjust: Callable[[Optional[Packet], int], int] = ...) -> None:
        ...
    
    def i2m(self, pkt: Optional[Packet], x: Optional[Any]) -> int:
        ...
    


class XBitField(BitField):
    def i2repr(self, pkt: Optional[Packet], x: int) -> str:
        ...
    


class _EnumField(Field[Union[List[I], I], I]):
    def __init__(self, name: str, default: Optional[I], enum: Union[Dict[I, str], Dict[str, I], List[str], DADict[I, str], Tuple[Callable[[I], str], Callable[[str], I]]], fmt: str = ...) -> None:
        """ Initializes enum fields.

        @param name:    name of this field
        @param default: default value of this field
        @param enum:    either a dict or a tuple of two callables. Dict keys are  # noqa: E501
                        the internal values, while the dict values are the
                        user-friendly representations. If the tuple is provided,  # noqa: E501
                        the first callable receives the internal value as
                        parameter and returns the user-friendly representation
                        and the second callable does the converse. The first
                        callable may return None to default to a literal string
                        (repr()) representation.
        @param fmt:     struct.pack format used to parse and serialize the
                        internal value from and to machine representation.
        """
        ...
    
    def any2i_one(self, pkt: Optional[Packet], x: Any) -> I:
        ...
    
    def i2repr_one(self, pkt: Optional[Packet], x: I) -> str:
        ...
    
    def any2i(self, pkt: Optional[Packet], x: Any) -> Union[I, List[I]]:
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: Any) -> Union[List[str], str]:
        ...
    
    def notify_set(self, enum: ObservableDict, key: I, value: str) -> None:
        ...
    
    def notify_del(self, enum: ObservableDict, key: I) -> None:
        ...
    


class EnumField(_EnumField[I]):
    __slots__ = ...


class CharEnumField(EnumField[str]):
    def __init__(self, name: str, default: str, enum: Union[Dict[str, str], Tuple[Callable[[str], str], Callable[[str], str]]], fmt: str = ...) -> None:
        ...
    
    def any2i_one(self, pkt: Optional[Packet], x: str) -> str:
        ...
    


class BitEnumField(_BitField[Union[List[int], int]], _EnumField[int]):
    __slots__ = ...
    def __init__(self, name: str, default: Optional[int], size: int, enum: Dict[int, str]) -> None:
        ...
    
    def any2i(self, pkt: Optional[Packet], x: Any) -> Union[List[int], int]:
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: Union[List[int], int]) -> Any:
        ...
    


class ShortEnumField(EnumField[int]):
    __slots__ = ...
    def __init__(self, name: str, default: int, enum: Union[Dict[int, str], Dict[str, int], Tuple[Callable[[int], str], Callable[[str], int]], DADict[int, str]]) -> None:
        ...
    


class LEShortEnumField(EnumField[int]):
    def __init__(self, name: str, default: int, enum: Union[Dict[int, str], List[str]]) -> None:
        ...
    


class ByteEnumField(EnumField[int]):
    def __init__(self, name: str, default: Optional[int], enum: Dict[int, str]) -> None:
        ...
    


class XByteEnumField(ByteEnumField):
    def i2repr_one(self, pkt: Optional[Packet], x: int) -> str:
        ...
    


class IntEnumField(EnumField[int]):
    def __init__(self, name: str, default: Optional[int], enum: Dict[int, str]) -> None:
        ...
    


class SignedIntEnumField(EnumField[int]):
    def __init__(self, name: str, default: Optional[int], enum: Dict[int, str]) -> None:
        ...
    


class LEIntEnumField(EnumField[int]):
    def __init__(self, name: str, default: int, enum: Dict[int, str]) -> None:
        ...
    


class XShortEnumField(ShortEnumField):
    def i2repr_one(self, pkt: Optional[Packet], x: int) -> str:
        ...
    


class _MultiEnumField(_EnumField[I]):
    def __init__(self, name: str, default: int, enum: Dict[I, Dict[I, str]], depends_on: Callable[[Optional[Packet]], I], fmt: str = ...) -> None:
        ...
    
    def any2i_one(self, pkt: Optional[Packet], x: Any) -> I:
        ...
    
    def i2repr_one(self, pkt: Optional[Packet], x: I) -> str:
        ...
    


class MultiEnumField(_MultiEnumField[int], EnumField[int]):
    __slots__ = ...


class BitMultiEnumField(_BitField[Union[List[int], int]], _MultiEnumField[int]):
    __slots__ = ...
    def __init__(self, name: str, default: int, size: int, enum: Dict[int, Dict[int, str]], depends_on: Callable[[Optional[Packet]], int]) -> None:
        ...
    
    def any2i(self, pkt: Optional[Packet], x: Any) -> Union[List[int], int]:
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: Union[List[int], int]) -> Union[str, List[str]]:
        ...
    


class ByteEnumKeysField(ByteEnumField):
    """ByteEnumField that picks valid values when fuzzed. """
    def randval(self) -> RandEnumKeys:
        ...
    


class ShortEnumKeysField(ShortEnumField):
    """ShortEnumField that picks valid values when fuzzed. """
    def randval(self) -> RandEnumKeys:
        ...
    


class IntEnumKeysField(IntEnumField):
    """IntEnumField that picks valid values when fuzzed. """
    def randval(self) -> RandEnumKeys:
        ...
    


class LEFieldLenField(FieldLenField):
    def __init__(self, name: str, default: int, length_of: Optional[str] = ..., fmt: str = ..., count_of: Optional[str] = ..., adjust: Callable[[Packet, int], int] = ...) -> None:
        ...
    


class FlagValueIter:
    __slots__ = ...
    def __init__(self, flagvalue: FlagValue) -> None:
        ...
    
    def __iter__(self) -> FlagValueIter:
        ...
    
    def __next__(self) -> str:
        ...
    
    next = ...


class FlagValue:
    __slots__ = ...
    def __init__(self, value: Union[List[str], int, str], names: Union[List[str], str]) -> None:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __int__(self) -> int:
        ...
    
    def __eq__(self, other: Any) -> bool:
        ...
    
    def __lt__(self, other: Any) -> bool:
        ...
    
    def __le__(self, other: Any) -> bool:
        ...
    
    def __gt__(self, other: Any) -> bool:
        ...
    
    def __ge__(self, other: Any) -> bool:
        ...
    
    def __ne__(self, other: Any) -> bool:
        ...
    
    def __and__(self, other: int) -> FlagValue:
        ...
    
    __rand__ = ...
    def __or__(self, other: int) -> FlagValue:
        ...
    
    __ror__ = ...
    def __lshift__(self, other: int) -> int:
        ...
    
    def __rshift__(self, other: int) -> int:
        ...
    
    def __nonzero__(self) -> bool:
        ...
    
    __bool__ = ...
    def flagrepr(self) -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __iter__(self) -> FlagValueIter:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __deepcopy__(self, memo: Dict[Any, Any]) -> FlagValue:
        ...
    
    def __getattr__(self, attr: str) -> Any:
        ...
    
    def __setattr__(self, attr: str, value: Union[List[str], int, str]) -> None:
        ...
    
    def copy(self) -> FlagValue:
        ...
    


class FlagsField(_BitField[Optional[Union[int, FlagValue]]]):
    """ Handle Flag type field

   Make sure all your flags have a label

   Example (list):
       >>> from scapy.packet import Packet
       >>> class FlagsTest(Packet):
               fields_desc = [FlagsField("flags", 0, 8, ["f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7"])]  # noqa: E501
       >>> FlagsTest(flags=9).show2()
       ###[ FlagsTest ]###
         flags     = f0+f3

    Example (str):
       >>> from scapy.packet import Packet
       >>> class TCPTest(Packet):
               fields_desc = [
                   BitField("reserved", 0, 7),
                   FlagsField("flags", 0x2, 9, "FSRPAUECN")
               ]
       >>> TCPTest(flags=3).show2()
       ###[ FlagsTest ]###
         reserved  = 0
         flags     = FS

    Example (dict):
       >>> from scapy.packet import Packet
       >>> class FlagsTest2(Packet):
               fields_desc = [
                   FlagsField("flags", 0x2, 16, {
                       1: "1",  # 1st bit
                       8: "2"   # 8th bit
                   })
               ]

   :param name: field's name
   :param default: default value for the field
   :param size: number of bits in the field (in bits)
   :param names: (list or str or dict) label for each flag
       If it's a str or a list, the least Significant Bit tag's name
       is written first.
   """
    ismutable = ...
    __slots__ = ...
    def __init__(self, name: str, default: Optional[Union[int, FlagValue]], size: int, names: Union[List[str], str, Dict[int, str]]) -> None:
        ...
    
    def any2i(self, pkt: Optional[Packet], x: Any) -> Optional[FlagValue]:
        ...
    
    def m2i(self, pkt: Optional[Packet], x: int) -> Optional[FlagValue]:
        ...
    
    def i2h(self, pkt: Optional[Packet], x: Any) -> Optional[FlagValue]:
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: Any) -> str:
        ...
    


MultiFlagsEntry = ...
class MultiFlagsField(_BitField[Set[str]]):
    __slots__ = ...
    def __init__(self, name: str, default: Set[str], size: int, names: Dict[int, Dict[int, MultiFlagsEntry]], depends_on: Callable[[Optional[Packet]], int]) -> None:
        ...
    
    def any2i(self, pkt: Optional[Packet], x: Any) -> Set[str]:
        ...
    
    def i2m(self, pkt: Optional[Packet], x: Optional[Set[str]]) -> int:
        ...
    
    def m2i(self, pkt: Optional[Packet], x: int) -> Set[str]:
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: Set[str]) -> str:
        ...
    


class FixedPointField(BitField):
    __slots__ = ...
    def __init__(self, name: str, default: int, size: int, frac_bits: int = ...) -> None:
        ...
    
    def any2i(self, pkt: Optional[Packet], val: Optional[float]) -> Optional[int]:
        ...
    
    def i2h(self, pkt: Optional[Packet], val: int) -> EDecimal:
        ...
    
    def i2repr(self, pkt: Optional[Packet], val: int) -> str:
        ...
    


class _IPPrefixFieldBase(Field[Tuple[str, int], Tuple[bytes, int]]):
    __slots__ = ...
    def __init__(self, name: str, default: Tuple[str, int], wordbytes: int, maxbytes: int, aton: Callable[..., Any], ntoa: Callable[..., Any], length_from: Optional[Callable[[Packet], int]] = ...) -> None:
        ...
    
    def h2i(self, pkt: Optional[Packet], x: str) -> Tuple[str, int]:
        ...
    
    def i2h(self, pkt: Optional[Packet], x: Tuple[str, int]) -> str:
        ...
    
    def i2m(self, pkt: Optional[Packet], x: Optional[Tuple[str, int]]) -> Tuple[bytes, int]:
        ...
    
    def m2i(self, pkt: Optional[Packet], x: Tuple[bytes, int]) -> Tuple[str, int]:
        ...
    
    def any2i(self, pkt: Optional[Packet], x: Optional[Any]) -> Tuple[str, int]:
        ...
    
    def i2len(self, pkt: Packet, x: Tuple[str, int]) -> int:
        ...
    
    def addfield(self, pkt: Packet, s: bytes, val: Optional[Tuple[str, int]]) -> bytes:
        ...
    
    def getfield(self, pkt: Packet, s: bytes) -> Tuple[bytes, Tuple[str, int]]:
        ...
    


class IPPrefixField(_IPPrefixFieldBase):
    def __init__(self, name: str, default: Tuple[str, int], wordbytes: int = ..., length_from: Optional[Callable[[Packet], int]] = ...) -> None:
        ...
    


class IP6PrefixField(_IPPrefixFieldBase):
    def __init__(self, name: str, default: Tuple[str, int], wordbytes: int = ..., length_from: Optional[Callable[[Packet], int]] = ...) -> None:
        ...
    


class UTCTimeField(Field[float, int]):
    __slots__ = ...
    def __init__(self, name: str, default: int, use_msec: bool = ..., use_micro: bool = ..., use_nano: bool = ..., epoch: Optional[Tuple[int, int, int, int, int, int, int, int, int]] = ..., strf: str = ...) -> None:
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: float) -> str:
        ...
    
    def i2m(self, pkt: Optional[Packet], x: Optional[float]) -> int:
        ...
    


class SecondsIntField(Field[float, int]):
    __slots__ = ...
    def __init__(self, name: str, default: int, use_msec: bool = ..., use_micro: bool = ..., use_nano: bool = ...) -> None:
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: Optional[float]) -> str:
        ...
    


class _ScalingField:
    def __init__(self, name: str, default: float, scaling: Union[int, float] = ..., unit: str = ..., offset: Union[int, float] = ..., ndigits: int = ..., fmt: str = ...) -> None:
        ...
    
    def i2m(self, pkt: Optional[Packet], x: Optional[Union[int, float]]) -> Union[int, float]:
        ...
    
    def m2i(self, pkt: Optional[Packet], x: Union[int, float]) -> Union[int, float]:
        ...
    
    def any2i(self, pkt: Optional[Packet], x: Any) -> Union[int, float]:
        ...
    
    def i2repr(self, pkt: Optional[Packet], x: Union[int, float]) -> str:
        ...
    
    def randval(self) -> RandFloat:
        ...
    


class ScalingField(_ScalingField, Field[Union[int, float], Union[int, float]]):
    """ Handle physical values which are scaled and/or offset for communication

       Example:
           >>> from scapy.packet import Packet
           >>> class ScalingFieldTest(Packet):
                   fields_desc = [ScalingField('data', 0, scaling=0.1, offset=-1, unit='mV')]  # noqa: E501
           >>> ScalingFieldTest(data=10).show2()
           ###[ ScalingFieldTest ]###
             data= 10.0 mV
           >>> hexdump(ScalingFieldTest(data=10))
           0000  6E                                               n
           >>> hexdump(ScalingFieldTest(data=b"\x6D"))
           0000  6D                                               m
           >>> ScalingFieldTest(data=b"\x6D").show2()
           ###[ ScalingFieldTest ]###
             data= 9.9 mV

        bytes(ScalingFieldTest(...)) will produce 0x6E in this example.
        0x6E is 110 (decimal). This is calculated through the scaling factor
        and the offset. "data" was set to 10, which means, we want to transfer
        the physical value 10 mV. To calculate the value, which has to be
        sent on the bus, the offset has to subtracted and the scaling has to be
        applied by division through the scaling factor.
        bytes = (data - offset) / scaling
        bytes = ( 10  -  (-1) ) /    0.1
        bytes =  110 = 0x6E

        If you want to force a certain internal value, you can assign a byte-
        string to the field (data=b"\x6D"). If a string of a bytes object is
        given to the field, no internal value conversion will be applied

       :param name: field's name
       :param default: default value for the field
       :param scaling: scaling factor for the internal value conversion
       :param unit: string for the unit representation of the internal value
       :param offset: value to offset the internal value during conversion
       :param ndigits: number of fractional digits for the internal conversion
       :param fmt: struct.pack format used to parse and serialize the internal value from and to machine representation # noqa: E501
       """
    ...


class BitScalingField(_ScalingField, BitField):
    """
    A ScalingField that is a BitField
    """
    def __init__(self, name: str, default: int, size: int, *args: Any, **kwargs: Any) -> None:
        ...
    


class OUIField(X3BytesField):
    """
    A field designed to carry a OUI (3 bytes)
    """
    def i2repr(self, pkt: Optional[Packet], val: int) -> str:
        ...
    


class UUIDField(Field[UUID, bytes]):
    """Field for UUID storage, wrapping Python's uuid.UUID type.

    The internal storage format of this field is ``uuid.UUID`` from the Python
    standard library.

    There are three formats (``uuid_fmt``) for this field type:

    * ``FORMAT_BE`` (default): the UUID is six fields in big-endian byte order,
      per RFC 4122.

      This format is used by DHCPv6 (RFC 6355) and most network protocols.

    * ``FORMAT_LE``: the UUID is six fields, with ``time_low``, ``time_mid``
      and ``time_high_version`` in little-endian byte order. This *doesn't*
      change the arrangement of the fields from RFC 4122.

      This format is used by Microsoft's COM/OLE libraries.

    * ``FORMAT_REV``: the UUID is a single 128-bit integer in little-endian
      byte order. This *changes the arrangement* of the fields.

      This format is used by Bluetooth Low Energy.

    Note: You should use the constants here.

    The "human encoding" of this field supports a number of different input
    formats, and wraps Python's ``uuid.UUID`` library appropriately:

    * Given a bytearray, bytes or str of 16 bytes, this class decodes UUIDs in
      wire format.

    * Given a bytearray, bytes or str of other lengths, this delegates to
      ``uuid.UUID`` the Python standard library. This supports a number of
      different encoding options -- see the Python standard library
      documentation for more details.

    * Given an int or long, presumed to be a 128-bit integer to pass to
      ``uuid.UUID``.

    * Given a tuple:

      * Tuples of 11 integers are treated as having the last 6 integers forming
        the ``node`` field, and are merged before being passed as a tuple of 6
        integers to ``uuid.UUID``.

      * Otherwise, the tuple is passed as the ``fields`` parameter to
        ``uuid.UUID`` directly without modification.

        ``uuid.UUID`` expects a tuple of 6 integers.

    Other types (such as ``uuid.UUID``) are passed through.
    """
    __slots__ = ...
    FORMAT_BE = ...
    FORMAT_LE = ...
    FORMAT_REV = ...
    FORMATS = ...
    def __init__(self, name: str, default: Optional[int], uuid_fmt: int = ...) -> None:
        ...
    
    def i2m(self, pkt: Optional[Packet], x: Optional[UUID]) -> bytes:
        ...
    
    def m2i(self, pkt: Optional[Packet], x: bytes) -> UUID:
        ...
    
    def any2i(self, pkt: Optional[Packet], x: Any) -> Optional[UUID]:
        ...
    
    @staticmethod
    def randval() -> RandUUID:
        ...
    


class BitExtendedField(Field[Optional[int], bytes]):
    """
    Bit Extended Field

    This type of field has a variable number of bytes. Each byte is defined
    as follows:
    - 7 bits of data
    - 1 bit an an extension bit:

      + 0 means it is last byte of the field ("stopping bit")
      + 1 means there is another byte after this one ("forwarding bit")

    To get the actual data, it is necessary to hop the binary data byte per
    byte and to check the extension bit until 0
    """
    __slots__ = ...
    def prepare_byte(self, x: int) -> int:
        ...
    
    def str2extended(self, x: bytes = ...) -> Tuple[bytes, Optional[int]]:
        ...
    
    def extended2str(self, x: Optional[int]) -> bytes:
        ...
    
    def __init__(self, name: str, default: Optional[Any], extension_bit: int) -> None:
        ...
    
    def i2m(self, pkt: Optional[Any], x: Optional[int]) -> bytes:
        ...
    
    def m2i(self, pkt: Optional[Any], x: bytes) -> Optional[int]:
        ...
    
    def addfield(self, pkt: Optional[Packet], s: bytes, val: Optional[int]) -> bytes:
        ...
    
    def getfield(self, pkt: Optional[Any], s: bytes) -> Tuple[bytes, Optional[int]]:
        ...
    


class LSBExtendedField(BitExtendedField):
    def __init__(self, name: str, default: Optional[Any]) -> None:
        ...
    


class MSBExtendedField(BitExtendedField):
    def __init__(self, name: str, default: Optional[Any]) -> None:
        ...
    


