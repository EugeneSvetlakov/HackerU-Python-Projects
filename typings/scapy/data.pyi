"""
This type stub file was generated by pyright.
"""

from scapy.dadict import DADict
from scapy.consts import FREEBSD, NETBSD, OPENBSD, WINDOWS
from scapy.compat import Any, Dict, List, Optional, Tuple

"""
Global variables and functions for handling external data sets.
"""
ETHER_ANY = ...
ETHER_BROADCAST = ...
SOL_PACKET = ...
SO_ATTACH_FILTER = ...
SO_TIMESTAMPNS = ...
ETH_P_ALL = ...
ETH_P_IP = ...
ETH_P_ARP = ...
ETH_P_IPV6 = ...
ETH_P_MACSEC = ...
ARPHDR_ETHER = ...
ARPHDR_METRICOM = ...
ARPHDR_PPP = ...
ARPHDR_LOOPBACK = ...
ARPHDR_TUN = ...
DLT_NULL = ...
DLT_EN10MB = ...
DLT_EN3MB = ...
DLT_AX25 = ...
DLT_PRONET = ...
DLT_CHAOS = ...
DLT_IEEE802 = ...
DLT_ARCNET = ...
DLT_SLIP = ...
DLT_PPP = ...
DLT_FDDI = ...
if OPENBSD:
    DLT_RAW = ...
else:
    DLT_RAW = ...
DLT_RAW_ALT = ...
if FREEBSD or NETBSD:
    DLT_SLIP_BSDOS = ...
    DLT_PPP_BSDOS = ...
else:
    DLT_SLIP_BSDOS = ...
    DLT_PPP_BSDOS = ...
if FREEBSD:
    DLT_PFSYNC = ...
else:
    DLT_PFSYNC = ...
    DLT_HHDLC = ...
DLT_ATM_CLIP = ...
DLT_PPP_SERIAL = ...
DLT_PPP_ETHER = ...
DLT_SYMANTEC_FIREWALL = ...
DLT_C_HDLC = ...
DLT_IEEE802_11 = ...
DLT_FRELAY = ...
if OPENBSD:
    DLT_LOOP = ...
    DLT_ENC = ...
else:
    DLT_LOOP = ...
    DLT_ENC = ...
DLT_LINUX_SLL = ...
DLT_LTALK = ...
DLT_PFLOG = ...
DLT_PRISM_HEADER = ...
DLT_AIRONET_HEADER = ...
DLT_IP_OVER_FC = ...
DLT_IEEE802_11_RADIO = ...
DLT_ARCNET_LINUX = ...
DLT_LINUX_IRDA = ...
DLT_IEEE802_11_RADIO_AVS = ...
DLT_LINUX_LAPD = ...
DLT_BLUETOOTH_HCI_H4 = ...
DLT_USB_LINUX = ...
DLT_PPI = ...
DLT_IEEE802_15_4_WITHFCS = ...
DLT_BLUETOOTH_HCI_H4_WITH_PHDR = ...
DLT_AX25_KISS = ...
DLT_PPP_WITH_DIR = ...
DLT_FC_2 = ...
DLT_CAN_SOCKETCAN = ...
if OPENBSD:
    DLT_IPV4 = ...
    DLT_IPV6 = ...
else:
    DLT_IPV4 = ...
    DLT_IPV6 = ...
DLT_IEEE802_15_4_NOFCS = ...
DLT_USBPCAP = ...
DLT_NETLINK = ...
DLT_USB_DARWIN = ...
DLT_BLUETOOTH_LE_LL = ...
DLT_BLUETOOTH_LE_LL_WITH_PHDR = ...
DLT_VSOCK = ...
DLT_ETHERNET_MPACKET = ...
IPV6_ADDR_UNICAST = ...
IPV6_ADDR_MULTICAST = ...
IPV6_ADDR_CAST_MASK = ...
IPV6_ADDR_LOOPBACK = ...
IPV6_ADDR_GLOBAL = ...
IPV6_ADDR_LINKLOCAL = ...
IPV6_ADDR_SITELOCAL = ...
IPV6_ADDR_SCOPE_MASK = ...
IPV6_ADDR_6TO4 = ...
IPV6_ADDR_UNSPECIFIED = ...
ARPHRD_ETHER = ...
ARPHRD_EETHER = ...
ARPHRD_AX25 = ...
ARPHRD_PRONET = ...
ARPHRD_CHAOS = ...
ARPHRD_IEEE802 = ...
ARPHRD_ARCNET = ...
ARPHRD_DLCI = ...
ARPHRD_ATM = ...
ARPHRD_METRICOM = ...
ARPHRD_SLIP = ...
ARPHRD_CSLIP = ...
ARPHRD_SLIP6 = ...
ARPHRD_CSLIP6 = ...
ARPHRD_ADAPT = ...
ARPHRD_CAN = ...
ARPHRD_PPP = ...
ARPHRD_CISCO = ...
ARPHRD_RAWHDLC = ...
ARPHRD_TUNNEL = ...
ARPHRD_FRAD = ...
ARPHRD_LOOPBACK = ...
ARPHRD_LOCALTLK = ...
ARPHRD_FDDI = ...
ARPHRD_SIT = ...
ARPHRD_FCPP = ...
ARPHRD_FCAL = ...
ARPHRD_FCPL = ...
ARPHRD_FCFABRIC = ...
ARPHRD_IRDA = ...
ARPHRD_IEEE802_TR = ...
ARPHRD_IEEE80211 = ...
ARPHRD_IEEE80211_PRISM = ...
ARPHRD_IEEE80211_RADIOTAP = ...
ARPHRD_IEEE802154 = ...
ARPHRD_NETLINK = ...
ARPHRD_VSOCKMON = ...
ARPHRD_LAPD = ...
ARPHRD_NONE = ...
ARPHRD_TO_DLT = ...
PPI_DOT11COMMON = ...
PPI_DOT11NMAC = ...
PPI_DOT11NMACPHY = ...
PPI_SPECTRUM_MAP = ...
PPI_PROCESS_INFO = ...
PPI_CAPTURE_INFO = ...
PPI_AGGREGATION = ...
PPI_DOT3 = ...
PPI_GPS = ...
PPI_VECTOR = ...
PPI_SENSOR = ...
PPI_ANTENNA = ...
PPI_BTLE = ...
PPI_TYPES = ...
EPOCH = ...
MTU = ...
IANA_ENTERPRISE_NUMBERS = ...
def load_protocols(filename: str, _fallback: Optional[bytes] = ..., _integer_base: int = ..., _cls: type = ...) -> DADict[int, str]:
    """"Parse /etc/protocols and return values as a dictionary."""
    ...

class EtherDA(DADict[int, str]):
    def __setitem__(self, attr: int, val: str) -> None:
        ...
    
    def __getitem__(self, attr: int) -> Any:
        ...
    


def load_ethertypes(filename: Optional[str]) -> EtherDA:
    """"Parse /etc/ethertypes and return values as a dictionary.
    If unavailable, use the copy bundled with Scapy."""
    ...

def load_services(filename: str) -> Tuple[DADict[int, str], DADict[int, str]]:
    ...

class ManufDA(DADict[str, Tuple[str, str]]):
    def ident(self, v: Any) -> str:
        ...
    
    def lookup(self, mac: str) -> Tuple[str, str]:
        """Find OUI name matching to a MAC"""
        ...
    
    def reverse_lookup(self, name: str, case_sensitive: bool = ...) -> Dict[str, str]:
        """
        Find all MACs registered to a OUI

        :param name: the OUI name
        :param case_sensitive: default to False
        :returns: a dict of mac:tuples (Name, Extended Name)
        """
        ...
    
    def __dir__(self) -> List[str]:
        ...
    


def load_manuf(filename: str) -> ManufDA:
    """
    Loads manuf file from Wireshark.

    :param filename: the file to load the manuf file from
    :returns: a ManufDA filled object
    """
    ...

def select_path(directories: List[str], filename: str) -> Optional[str]:
    """Find filename among several directories"""
    ...

if WINDOWS:
    IP_PROTOS = ...
    ETHER_TYPES = ...
    MANUFDB = ...
else:
    IP_PROTOS = ...
    ETHER_TYPES = ...
    MANUFDB = ...
    manuf_path = ...
class KnowledgeBase:
    def __init__(self, filename: Optional[Any]) -> None:
        ...
    
    def lazy_init(self) -> None:
        ...
    
    def reload(self, filename: Optional[Any] = ...) -> None:
        ...
    
    def get_base(self) -> str:
        ...
    


