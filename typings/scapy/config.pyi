"""
This type stub file was generated by pyright.
"""

import scapy
from scapy.compat import Any, Callable, DecoratorCallable, Dict, Iterator, List, NoReturn, Optional, TYPE_CHECKING, Tuple, Type, Union
from scapy.packet import Packet

"""
Implementation of the configuration object.
"""
if TYPE_CHECKING:
    ...
class ConfClass:
    def configure(self, cnf: ConfClass) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __str__(self) -> str:
        ...
    


class Interceptor:
    def __init__(self, name: str, default: Any, hook: Callable[..., Any], args: Optional[List[Any]] = ..., kargs: Optional[Dict[str, Any]] = ...) -> None:
        ...
    
    def __get__(self, obj: Conf, typ: Optional[type] = ...) -> Any:
        ...
    
    @staticmethod
    def set_from_hook(obj: Conf, name: str, val: bool) -> None:
        ...
    
    def __set__(self, obj: Conf, val: Any) -> None:
        ...
    


ReadOnlyAttribute = ...
class ProgPath(ConfClass):
    _default = ...
    universal_open = ...
    pdfreader = ...
    psreader = ...
    svgreader = ...
    dot = ...
    display = ...
    tcpdump = ...
    tcpreplay = ...
    hexedit = ...
    tshark = ...
    wireshark = ...
    ifconfig = ...


class ConfigFieldList:
    def __init__(self) -> None:
        ...
    
    def add(self, *flds: Any) -> None:
        ...
    
    def remove(self, *flds: Any) -> None:
        ...
    
    def __contains__(self, elt: Any) -> bool:
        ...
    
    def __repr__(self) -> str:
        ...
    


class Emphasize(ConfigFieldList):
    ...


class Resolve(ConfigFieldList):
    ...


class Num2Layer:
    def __init__(self) -> None:
        ...
    
    def register(self, num: int, layer: Type[Packet]) -> None:
        ...
    
    def register_num2layer(self, num: int, layer: Type[Packet]) -> None:
        ...
    
    def register_layer2num(self, num: int, layer: Type[Packet]) -> None:
        ...
    
    def __getitem__(self, item: Union[int, Type[Packet]]) -> Union[int, Type[Packet]]:
        ...
    
    def __contains__(self, item: Union[int, Type[Packet]]) -> bool:
        ...
    
    def get(self, item: Union[int, Type[Packet]], default: Optional[Type[Packet]] = ...) -> Optional[Union[int, Type[Packet]]]:
        ...
    
    def __repr__(self) -> str:
        ...
    


class LayersList(List[Type['scapy.packet.Packet']]):
    def __init__(self) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def register(self, layer: Type[Packet]) -> None:
        ...
    
    def layers(self) -> List[Tuple[str, str]]:
        ...
    
    def filter(self, items: List[Type[Packet]]) -> None:
        """Disable dissection of unused layers to speed up dissection"""
        ...
    
    def unfilter(self) -> None:
        """Re-enable dissection for all layers"""
        ...
    


class CommandsList(List[Callable[..., Any]]):
    def __repr__(self) -> str:
        ...
    
    def register(self, cmd: DecoratorCallable) -> DecoratorCallable:
        ...
    


def lsc() -> None:
    """Displays Scapy's default commands"""
    ...

class CacheInstance(Dict[str, Any]):
    __slots__ = ...
    def __init__(self, name: str = ..., timeout: Optional[int] = ...) -> None:
        ...
    
    def flush(self) -> None:
        ...
    
    def __getitem__(self, item: str) -> Any:
        ...
    
    def get(self, item: str, default: Optional[Any] = ...) -> Any:
        ...
    
    def __setitem__(self, item: str, v: str) -> None:
        ...
    
    def update(self, other: Any, **kwargs: Any) -> None:
        ...
    
    def iteritems(self) -> Iterator[Tuple[str, Any]]:
        ...
    
    def iterkeys(self) -> Iterator[str]:
        ...
    
    def __iter__(self) -> Iterator[str]:
        ...
    
    def itervalues(self) -> Iterator[Tuple[str, Any]]:
        ...
    
    def items(self) -> Any:
        ...
    
    def keys(self) -> Any:
        ...
    
    def values(self) -> Any:
        ...
    
    def __len__(self) -> int:
        ...
    
    def summary(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def copy(self) -> CacheInstance:
        ...
    


class NetCache:
    def __init__(self) -> None:
        ...
    
    def add_cache(self, cache: CacheInstance) -> None:
        ...
    
    def new_cache(self, name: str, timeout: Optional[int] = ...) -> CacheInstance:
        ...
    
    def __delattr__(self, attr: str) -> NoReturn:
        ...
    
    def update(self, other: NetCache) -> None:
        ...
    
    def flush(self) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    


def isCryptographyValid() -> bool:
    """
    Check if the cryptography module >= 2.0.0 is present. This is the minimum
    version for most usages in Scapy.
    """
    ...

def isCryptographyAdvanced() -> bool:
    """
    Check if the cryptography module is present, and if it supports X25519,
    ChaCha20Poly1305 and such.

    Notes:
    - cryptography >= 2.0 is required
    - OpenSSL >= 1.1.0 is required
    """
    ...

def isPyPy() -> bool:
    """Returns either scapy is running under PyPy or not"""
    ...

class Conf(ConfClass):
    """
    This object contains the configuration of Scapy.
    """
    version = ...
    session = ...
    interactive = ...
    interactive_shell = ...
    stealth = ...
    iface: scapy.interfaces.NetworkInterface = ...
    layers = ...
    commands: CommandsList = ...
    ASN1_default_codec = ...
    AS_resolver = ...
    dot15d4_protocol = ...
    logLevel = ...
    checkIPID = ...
    checkIPsrc = ...
    checkIPaddr = ...
    checkIPinIP = ...
    check_TCPerror_seqack = ...
    verb = ...
    prompt = ...
    promisc = ...
    sniff_promisc = ...
    raw_layer: Type[Packet] = ...
    raw_summary = ...
    padding_layer: Type[Packet] = ...
    default_l2: Type[Packet] = ...
    l2types = ...
    l3types = ...
    L3socket: Type[scapy.supersocket.SuperSocket] = ...
    L3socket6: Type[scapy.supersocket.SuperSocket] = ...
    L2socket: Type[scapy.supersocket.SuperSocket] = ...
    L2listen: Type[scapy.supersocket.SuperSocket] = ...
    BTsocket: Type[scapy.supersocket.SuperSocket] = ...
    USBsocket: Type[scapy.supersocket.SuperSocket] = ...
    min_pkt_size = ...
    mib: scapy.asn1.mib.MIBDict = ...
    bufsize = ...
    histfile = ...
    padding = ...
    except_filter = ...
    filter = ...
    debug_match = ...
    debug_tls = ...
    wepkey = ...
    ifaces: scapy.interfaces.NetworkInterfaceDict = ...
    cache_pcapiflist: Dict[str, Tuple[str, List[str], int]] = ...
    neighbor: scapy.layers.l2.Neighbor = ...
    route: scapy.route.Route = ...
    route6: scapy.route6.Route6 = ...
    manufdb: scapy.data.ManufDA = ...
    teredoPrefix: str = ...
    teredoServerPort: int = ...
    auto_fragment = ...
    debug_dissector = ...
    color_theme = ...
    warning_threshold = ...
    prog = ...
    resolve = ...
    noenum = ...
    emph = ...
    use_pypy = ...
    use_pcap = ...
    use_bpf = ...
    use_npcap = ...
    ipv6_enabled = ...
    extensions_paths = ...
    stats_classic_protocols: List[Type[Packet]] = ...
    stats_dot11_protocols: List[Type[Packet]] = ...
    temp_files: List[str] = ...
    netcache = ...
    geoip_city = ...
    load_layers = ...
    contribs: Dict[str, Any] = ...
    crypto_valid = ...
    crypto_valid_advanced = ...
    fancy_prompt = ...
    auto_crop_tables = ...
    recv_poll_rate = ...
    raise_no_dst_mac = ...
    loopback_name = ...
    def __getattribute__(self, attr: str) -> Any:
        ...
    


if notConf.ipv6_enabled:
    ...
conf: Conf = ...
def crypto_validator(func: DecoratorCallable) -> DecoratorCallable:
    """
    This a decorator to be used for any method relying on the cryptography library.  # noqa: E501
    Its behaviour depends on the 'crypto_valid' attribute of the global 'conf'.
    """
    ...

def scapy_delete_temp_files() -> None:
    ...

