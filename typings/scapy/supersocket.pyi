"""
This type stub file was generated by pyright.
"""

import ctypes
import socket
import scapy.modules.six as six
from scapy.compat import Any, List, Optional, Tuple, Type
from scapy.interfaces import _GlobInterfaceType
from scapy.packet import Packet
from scapy.plist import PacketList, SndRcvList, _PacketIterable

"""
SuperSocket.
"""
class _SuperSocket_metaclass(type):
    desc: Optional[str] = ...
    def __repr__(self) -> str:
        ...
    


PACKET_AUXDATA: int = ...
ETH_P_8021Q: int = ...
TP_STATUS_VLAN_VALID: int = ...
class tpacket_auxdata(ctypes.Structure):
    _fields_: List[Tuple[str, Any]] = ...


@six.add_metaclass(_SuperSocket_metaclass)
class SuperSocket:
    closed: int = ...
    nonblocking_socket: bool = ...
    auxdata_available: bool = ...
    def __init__(self, family: int = ..., type: int = ..., proto: int = ..., iface: Optional[_GlobInterfaceType] = ..., **kwargs: Any) -> None:
        ...
    
    def send(self, x: Packet) -> int:
        ...
    
    if six.PY2:
        ...
    else:
        ...
    def recv_raw(self, x: int = ...) -> Tuple[Optional[Type[Packet]], Optional[bytes], Optional[float]]:
        """Returns a tuple containing (cls, pkt_data, time)"""
        ...
    
    def recv(self, x: int = ...) -> Optional[Packet]:
        ...
    
    def fileno(self) -> int:
        ...
    
    def close(self) -> None:
        ...
    
    def sr(self, *args: Any, **kargs: Any) -> Tuple[SndRcvList, PacketList]:
        ...
    
    def sr1(self, *args: Any, **kargs: Any) -> Optional[Packet]:
        ...
    
    def sniff(self, *args: Any, **kargs: Any) -> PacketList:
        ...
    
    def tshark(self, *args: Any, **kargs: Any) -> None:
        ...
    
    def am(self, cls: Type[Any], *args: Any, **kwargs: Any) -> Any:
        """
        Creates an AnsweringMachine associated with this socket.

        :param cls: A subclass of AnsweringMachine to instantiate
        """
        ...
    
    @staticmethod
    def select(sockets: List[SuperSocket], remain: Optional[float] = ...) -> List[SuperSocket]:
        """This function is called during sendrecv() routine to select
        the available sockets.

        :param sockets: an array of sockets that need to be selected
        :returns: an array of sockets that were selected and
            the function to be called next to get the packets (i.g. recv)
        """
        ...
    
    def __del__(self) -> None:
        """Close the socket"""
        ...
    
    def __enter__(self) -> SuperSocket:
        ...
    
    def __exit__(self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[Any]) -> None:
        """Close the socket"""
        ...
    


class L3RawSocket(SuperSocket):
    desc = ...
    def __init__(self, type: int = ..., filter: Optional[str] = ..., iface: Optional[_GlobInterfaceType] = ..., promisc: Optional[bool] = ..., nofilter: int = ...) -> None:
        ...
    
    def recv(self, x: int = ...) -> Optional[Packet]:
        ...
    
    def send(self, x: Packet) -> int:
        ...
    


class SimpleSocket(SuperSocket):
    desc = ...
    nonblocking_socket = ...
    def __init__(self, sock: socket.socket) -> None:
        ...
    


class StreamSocket(SimpleSocket):
    desc = ...
    def __init__(self, sock: socket.socket, basecls: Optional[Type[Packet]] = ...) -> None:
        ...
    
    def recv(self, x: int = ...) -> Optional[Packet]:
        ...
    


class SSLStreamSocket(StreamSocket):
    desc = ...
    def __init__(self, sock: socket.socket, basecls: Optional[Type[Packet]] = ...) -> None:
        ...
    
    def recv(self, x: int = ...) -> Optional[Packet]:
        ...
    


class L2ListenTcpdump(SuperSocket):
    desc = ...
    def __init__(self, iface: Optional[_GlobInterfaceType] = ..., promisc: bool = ..., filter: Optional[str] = ..., nofilter: bool = ..., prog: Optional[str] = ..., *arg: Any, **karg: Any) -> None:
        ...
    
    def recv(self, x: int = ...) -> Optional[Packet]:
        ...
    
    def close(self) -> None:
        ...
    
    @staticmethod
    def select(sockets: List[SuperSocket], remain: Optional[float] = ...) -> List[SuperSocket]:
        ...
    


class IterSocket(SuperSocket):
    desc = ...
    nonblocking_socket = ...
    def __init__(self, obj: _PacketIterable) -> None:
        ...
    
    @staticmethod
    def select(sockets: List[SuperSocket], remain: Any = ...) -> List[SuperSocket]:
        ...
    
    def recv(self, *args: Any) -> Optional[Packet]:
        ...
    
    def close(self) -> None:
        ...
    


